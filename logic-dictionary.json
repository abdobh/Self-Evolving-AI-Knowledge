{
    "rules": {
        "string_manipulation_rule_from_search": {
            "type": "string_manipulation",
            "values": [],
            "linked_to": [],
            "source": "external_search",
            "confidence": 70,
            "last_verified": "2025-08-25T00:56:05.295410"
        },
        "semantic_relation_planet": {
            "type": "semantic",
            "values": [
                "planet http://www.wikidata.org/prop/direct/P31 astronomical object type"
            ],
            "linked_to": [],
            "source": "open_source_db_search",
            "confidence": 80,
            "last_verified": "2025-08-25T00:41:15.076175"
        },
        "add_value": {
            "type": "mathematical",
            "values": [
                -46,
                -42,
                -37,
                -24,
                -23,
                -21,
                -16,
                -13,
                -10,
                -4,
                -3,
                1,
                4,
                5,
                12,
                16,
                22,
                27,
                34,
                45,
                48,
                147
            ],
            "linked_to": [],
            "source": "internal_reasoning",
            "confidence": 90,
            "last_verified": "2025-08-25T00:55:20.077386"
        },
        "wikidata_relation_P17": {
            "type": "geographical",
            "values": [
                "Cairo -> http://www.wikidata.org/prop/direct/P17 -> Egypt",
                "London -> http://www.wikidata.org/prop/direct/P17 -> United Kingdom",
                "Paris -> http://www.wikidata.org/prop/direct/P17 -> France",
                "Tokyo -> http://www.wikidata.org/prop/direct/P17 -> Japan"
            ],
            "linked_to": [],
            "source": "open_source_db_search",
            "confidence": 80,
            "last_verified": "2025-08-25T00:55:36.582946"
        },
        "self_built_algorithm_control_flow": {
            "type": "control_flow",
            "value": "\n# خوارزمية تم توليدها ذاتيًا لطباعة الأرقام\ndef print_numbers(start, end):\n    # نستخدم حلقة `for` لتكرار العملية\n    for number in range(start, end + 1):\n        print(number)\n\n# مثال على الاستخدام:\nprint_numbers(1, 5)\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:00:16.576670"
        },
        "self_built_algorithm_function_definition": {
            "type": "function_definition",
            "value": "\n# خوارزمية تم توليدها ذاتيًا لتعريف دالة جمع\ndef add_two_numbers(a, b):\n    # نقوم بعملية الجمع البسيطة\n    return a + b\n\n# مثال على الاستخدام:\nresult = add_two_numbers((2, 5), 7)\nprint(f\"ناتج جمع (2, 5) و 7 هو: {result}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:00:28.910355"
        },
        "self_built_algorithm_data_structures": {
            "type": "data_structures",
            "value": "\n# خوارزمية تم توليدها ذاتيًا لتحويل قائمة إلى قاموس\ndef convert_list_to_dict(input_list):\n    # نستخدم فهم القاموس لتنفيذ العملية\n    output_dict = {item: True for item in input_list}\n    return output_dict\n\n# مثال على الاستخدام:\nmy_list = [5, 20, 25]\nmy_dict = convert_list_to_dict(my_list)\nprint(f\"القائمة الأصلية: {my_list}\")\nprint(f\"القاموس الناتج: {my_dict}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:00:41.089495"
        },
        "self_built_algorithm_simple_arithmetic": {
            "type": "simple_arithmetic",
            "value": "\n# خوارزمية تم توليدها ذاتيًا لعملية حسابية\ndef find_relation(start_val, target_val):\n    # نوجد الفرق بين الرقمين\n    difference = target_val - start_val\n    # يمكننا إضافة Difference لتصل إلى Target\n    return start_val + difference\n\n# مثال على الاستخدام:\nresult = find_relation(38, 111)\nprint(f\"العلاقة بين 38 و 111 هي: {result}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:00:52.956896"
        },
        "self_built_algorithm_sorting_algorithm": {
            "type": "sorting_algorithm",
            "value": "\n# خوارزمية فرز فقاعي تم توليدها ذاتيًا\ndef bubble_sort(unsorted_list):\n    n = len(unsorted_list)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if unsorted_list[j] > unsorted_list[j+1]:\n                unsorted_list[j], unsorted_list[j+1] = unsorted_list[j+1], unsorted_list[j]\n    return unsorted_list\n\n# مثال على الاستخدام:\nmy_list = [3, 50, 35, 38, 16]\nsorted_list = bubble_sort(my_list)\nprint(f\"القائمة غير المرتبة: {my_list}\")\nprint(f\"القائمة المرتبة: {sorted_list}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:09:34.243223"
        },
        "self_built_algorithm_file_handling": {
            "type": "file_handling",
            "value": "\n# خوارزمية تم توليدها ذاتيًا للتعامل مع الملفات\ndef write_to_file(file_name, content):\n    try:\n        with open(file_name, 'w') as f:\n            f.write(content)\n        print(f\"تم كتابة المحتوى بنجاح في الملف: '{file_name}'\")\n    except Exception as e:\n        print(f\"حدث خطأ أثناء الكتابة إلى الملف: {e}\")\n\n# مثال على الاستخدام:\nfile_to_write = \"test_file.txt\"\ncontent_to_write = \"تم توليد هذا المحتوى في 2025-08-25T01:09:45.739265\"\nwrite_to_file(file_to_write, content_to_write)\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:09:45.739615"
        },
        "self_built_algorithm_oop": {
            "type": "oop",
            "value": "\n# خوارزمية تم توليدها ذاتيًا للبرمجة كائنية التوجه (OOP)\nclass Car:\n    def __init__(self, color=\"red\"):\n        self.color = color\n        print(f\"تم إنشاء كائن جديد من فئة {self.__class__.__name__} بلون {self.color}.\")\n\n    def get_color(self):\n        return self.color\n\n# مثال على الاستخدام:\nmy_car = Car(color=\"blue\")\nprint(f\"لون {instance_name} هو: {my_car.get_color()}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:09:57.616537"
        },
        "self_built_algorithm_recursion": {
            "type": "recursion",
            "value": "\n# دالة مضروب (factorial) تم توليدها ذاتيًا باستخدام العودية (recursion)\ndef factorial(n):\n    # حالة الأساس (Base Case)\n    if n == 0:\n        return 1\n    # الحالة العودية (Recursive Case)\n    else:\n        return n * factorial(n-1)\n\n# مثال على الاستخدام:\nnumber = 7\nresult = factorial(number)\nprint(f\"مضروب الرقم {number} هو: {result}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:10:09.496071"
        },
        "self_built_algorithm_graph_theory": {
            "type": "graph_theory",
            "value": "\nimport collections\n\n# خوارزمية تم توليدها ذاتيًا لإيجاد أقصر مسار (BFS)\ndef find_shortest_path(graph, start, end):\n    # نستخدم قائمة انتظار (queue) لاستكشاف الرسم البياني\n    queue = collections.deque([[start]])\n    visited = {start}\n\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n\n        if node == end:\n            return path\n        \n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append(new_path)\n    \n    return None\n\n# مثال على الاستخدام:\nmy_graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E'], 'D': ['E'], 'E': []}\nstart_node = 'A'\nend_node = 'E'\nshortest_path = find_shortest_path(my_graph, start_node, end_node)\nprint(f\"أقصر مسار من {start_node} إلى {end_node} هو: {shortest_path}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:18:17.161250"
        },
        "self_built_algorithm_string_processing": {
            "type": "string_processing",
            "value": "\nimport collections\nimport re\n\n# خوارزمية تم توليدها ذاتيًا لتحليل النصوص (String Processing)\ndef analyze_text_string(text):\n    # نقوم بتحويل النص إلى أحرف صغيرة وتقسيمه إلى كلمات\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n\n    # نستخدم collections.Counter لعد تكرار كل كلمة\n    word_counts = collections.Counter(words)\n\n    # نطبع النتائج\n    print(f\"النص الأصلي: '{text}'\")\n    print(f\"عدد الكلمات الإجمالي: {len(words)}\")\n    print(f\"عدد تكرار كل كلمة: {dict(word_counts)}\")\n    return dict(word_counts)\n\n# مثال على الاستخدام:\nmy_string = \"Hello world hello world this is a test\"\nanalyze_text_string(my_string)\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:24:17.362088"
        },
        "self_built_algorithm_dynamic_programming": {
            "type": "dynamic_programming",
            "value": "\n# خوارزمية تم توليدها ذاتيًا باستخدام البرمجة الديناميكية (Dynamic Programming)\n# لحساب أرقام فيبوناتشي باستخدام التخزين المؤقت (Memoization)\ndef fibonacci(n, memo={}):\n    # إذا كانت القيمة موجودة بالفعل في الذاكرة المؤقتة، نعيدها مباشرة\n    if n in memo:\n        return memo[n]\n\n    # الحالات الأساسية (Base Cases)\n    if n <= 1:\n        return n\n\n    # حساب القيمة وتخزينها في الذاكرة المؤقتة قبل الإرجاع\n    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n    return memo[n]\n\n# مثال على الاستخدام:\nnumber_to_calculate = 8\nresult = fibonacci(number_to_calculate)\nprint(f\"قيمة فيبوناتشي للعدد {number_to_calculate} هي: {result}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:28:20.053795"
        },
        "self_built_algorithm_search_and_optimization": {
            "type": "search_and_optimization",
            "value": "\nimport heapq\nimport math\n\n# خوارزمية A* تم توليدها ذاتيًا لإيجاد أقصر مسار على شبكة\ndef a_star_pathfinding(grid, start, end):\n    # دالة التقدير (Heuristic) - مسافة مانهاتن\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    rows, cols = len(grid), len(grid[0])\n    # F-score (g-score + heuristic)\n    f_score = {node: float('inf') for row in range(rows) for node in range(cols)}\n    f_score[start] = heuristic(start, end)\n    \n    # G-score (التكلفة من البداية)\n    g_score = {node: float('inf') for row in range(rows) for node in range(cols)}\n    g_score[start] = 0\n\n    # قائمة الأولوية للعقد المراد استكشافها\n    open_list = [(f_score[start], start)]\n    came_from = {}\n\n    while open_list:\n        current_f, current_node = heapq.heappop(open_list)\n        \n        if current_node == end:\n            # إعادة بناء المسار\n            path = []\n            while current_node in came_from:\n                path.append(current_node)\n                current_node = came_from[current_node]\n            path.append(start)\n            path.reverse()\n            return path\n        \n        # استكشاف الجيران\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current_node[0] + dr, current_node[1] + dc)\n            \n            # التحقق من صلاحية الجار\n            if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0:\n                tentative_g_score = g_score[current_node] + 1 # تكلفة الخطوة\n                \n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current_node\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                    heapq.heappush(open_list, (f_score[neighbor], neighbor))\n                    \n    return None\n\n# مثال على الاستخدام:\nmy_grid = [[0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nstart_pos = (0, 0)\nend_pos = (2, 3)\n\npath = a_star_pathfinding(my_grid, start_pos, end_pos)\nprint(f\"الشبكة: {my_grid}\")\nprint(f\"أقصر مسار من {start_pos} إلى {end_pos} هو: {path}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:36:29.594914"
        },
        "self_built_algorithm_kruskal_mst": {
            "type": "kruskal_mst",
            "value": "\n# خوارزمية كروسكال (Kruskal's Algorithm) تم توليدها ذاتيًا لإيجاد شجرة الامتداد الدنيا (MST)\n\n# دالة مساعدة لإيجاد الجذر (find set)\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\n# دالة مساعدة لتوحيد المجموعات (union set)\ndef union(parent, rank, x, y):\n    root_x = find(parent, x)\n    root_y = find(parent, y)\n    if root_x != root_y:\n        if rank[root_x] > rank[root_y]:\n            parent[root_y] = root_x\n        elif rank[root_x] < rank[root_y]:\n            parent[root_x] = root_y\n        else:\n            parent[root_y] = root_x\n            rank[root_x] += 1\n        return True\n    return False\n\ndef kruskal_mst(edges):\n    mst = []\n    edges.sort(key=lambda item: item[2]) # فرز الحواف حسب الوزن\n\n    parent = {}\n    rank = {}\n    for u, v, w in edges:\n        parent[u] = u\n        parent[v] = v\n        rank[u] = 0\n        rank[v] = 0\n\n    num_edges = 0\n    i = 0\n    while num_edges < len(parent) - 1:\n        u, v, w = edges[i]\n        i += 1\n\n        root_u = find(parent, u)\n        root_v = find(parent, v)\n\n        if root_u != root_v:\n            mst.append((u, v))\n            union(parent, rank, root_u, root_v)\n            num_edges += 1\n\n    return mst\n\n# مثال على الاستخدام:\nmy_edges = [('A', 'B', 2), ('A', 'C', 3), ('B', 'C', 4), ('B', 'D', 5), ('C', 'D', 1)]\nmst_edges = kruskal_mst(my_edges)\nprint(f\"قائمة الحواف: {my_edges}\")\nprint(f\"شجرة الامتداد الدنيا (باستخدام كروسكال) هي: {mst_edges}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 75,
            "last_verified": "2025-08-25T01:47:43.984034"
        },
        "self_built_algorithm_prim_mst": {
            "type": "prim_mst",
            "value": "\nimport heapq\n\n# خوارزمية بريم (Prim's Algorithm) تم توليدها ذاتيًا لإيجاد شجرة الامتداد الدنيا (MST)\ndef prim_mst(graph, start_node):\n    mst = []\n    visited = {}\n    min_heap = [(0, start_node, None)] # (weight, node, parent)\n\n    while min_heap:\n        weight, current_node, parent = heapq.heappop(min_heap)\n\n        if current_node in visited:\n            continue\n\n        visited[current_node] = True\n        \n        if parent is not None:\n            mst.append((parent, current_node, weight))\n\n        for neighbor, edge_weight in graph.get(current_node, []):\n            if neighbor not in visited:\n                heapq.heappush(min_heap, (edge_weight, neighbor, current_node))\n    \n    # تحويل قائمة المسارات إلى تنسيق أبسط (node1, node2)\n    simple_mst = [(edge[0], edge[1]) for edge in mst]\n    return simple_mst\n\n# مثال على الاستخدام:\nmy_graph = {'A': [('B', 2), ('C', 3)], 'B': [('A', 2), ('C', 4), ('D', 5)], 'C': [('A', 3), ('B', 4), ('D', 1)], 'D': [('B', 5), ('C', 1)]}\nstart = 'A'\nmst_edges = prim_mst(my_graph, start)\nprint(f\"الرسم البياني: {my_graph}\")\nprint(f\"شجرة الامتداد الدنيا (باستخدام بريم) هي: {mst_edges}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:47:55.711645"
        },
        "self_built_algorithm_dijkstra_pathfinding": {
            "type": "dijkstra_pathfinding",
            "value": "\nimport heapq\n\n# خوارزمية ديكسترا تم توليدها ذاتيًا لإيجاد أقصر مسار في رسم بياني مرجح\ndef dijkstra_pathfinding(graph, start, end):\n    # مسافات (Distances)\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    # قائمة الأولوية (Priority Queue)\n    priority_queue = [(0, start)]\n    \n    # المسارات (Paths)\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n            \n        if current_node == end:\n            return paths[end]\n            \n        for neighbor, weight in graph.get(current_node, {}).items():\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n                \n                paths[neighbor] = paths[current_node] + [neighbor]\n                \n    return None\n\n# مثال على الاستخدام:\nmy_graph = {'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'C': 2, 'D': 5}, 'C': {'A': 4, 'B': 2, 'D': 1}, 'D': {'B': 5, 'C': 1, 'E': 3}, 'E': {}}\nstart_pos = 'A'\nend_pos = 'E'\n\npath = dijkstra_pathfinding(my_graph, start_pos, end_pos)\n# note: total_distance would require modification to access distances dict. For simplicity, we only return the path.\nprint(f\"أقصر مسار من {start_pos} إلى {end_pos} هو: {path}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 100,
            "last_verified": "2025-08-25T01:48:07.700789"
        },
        "data_structures_rule_from_search": {
            "type": "data_structures",
            "value": "{\n  \"cells\": [\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"view-in-github\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"<a href=\\\"https://colab.research.google.com/github/zcqin/PRML-2025/blob/main/Basics_Python_Coding_Part2.ipynb\\\" target=\\\"_parent\\\"><img src=\\\"https://colab.research.google.com/assets/colab-badge.svg\\\" alt=\\\"Open In Colab\\\"/></a>\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"OzvZXz9gKXsP\"\n      },\n      \"source\": [\n        \"### **Basics of Python Coding - Part 2**\\n\",\n        \"**Zengchang Qin (PhD)**\\n\",\n        \"\\n\",\n        \"Feb 02, 2024\\n\",\n        \"\\n\",\n        \"zengchang.qin@gmail.com\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"source\": [],\n      \"metadata\": {\n        \"id\": \"7jJbabVezspl\"\n      },\n      \"execution_count\": null,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"pntN8SB9OwiX\"\n      },\n      \"source\": [\n        \"[10] Iteration - Loops\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\"\n        },\n        \"id\": \"qi9NUWfznX04\",\n        \"outputId\": \"746fbd41-52b4-4ca6-c6e4-b3d47d6788d4\"\n      },\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"name\": \"stdout\",\n          \"text\": [\n            \"1 1\\n\",\n            \"2 3\\n\",\n            \"3 6\\n\",\n            \"4 10\\n\",\n            \"a\\n\",\n            \"p\\n\",\n            \"p\\n\",\n            \"l\\n\",\n            \"e\\n\",\n            \"Fibonacci Series are:\\n\",\n            \"1 :  1\\n\",\n            \"2 :  1\\n\",\n            \"3 :  2\\n\",\n            \"4 :  3\\n\",\n            \"5 :  5\\n\",\n            \"6 :  8\\n\",\n            \"7 :  13\\n\",\n            \"8 :  21\\n\",\n            \"9 :  34\\n\"\n          ]\n        }\n      ],\n      \"source\": [\n        \"import numpy as np\\n\",\n        \"n = 0\\n\",\n        \"\\n\",\n        \"for i in range(1, 5):\\n\",\n        \"    n = n + i\\n\",\n        \"    print(i,n)\\n\",\n        \"\\n\",\n        \"for c in \\\"apple\\\":\\n\",\n        \"    print(c)\\n\",\n        \"\\n\",\n        \"\\n\",\n        \"\\n\",\n        \"# Simple Fibonacci series generation\\n\",\n        \"a = 1\\n\",\n        \"b = 1\\n\",\n        \"print(\\\"Fibonacci Series are:\\\")\\n\",\n        \"print(1, \\\": \\\",a)\\n\",\n        \"print(2, \\\": \\\",b)\\n\",\n        \"\\n\",\n        \"for i in range(3, 10):\\n\",\n        \"    c = a + b\\n\",\n        \"    print(i, \\\": \\\", c)\\n\",\n        \"    a = b\\n\",\n        \"    b = c\\n\",\n        \"\\n\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\"\n        },\n        \"id\": \"se3aT518qcZV\",\n        \"outputId\": \"3224224a-5d62-4ef4-b0d2-9f632a44e356\"\n      },\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"name\": \"stdout\",\n          \"text\": [\n            \"value of One is 1\\n\",\n            \"value of Two is 2\\n\",\n            \"value of Three is 3\\n\"\n          ]\n        }\n      ],\n      \"source\": [\n        \"dict_a = {\\\"One\\\":1, \\\"Two\\\":2, \\\"Three\\\":3}\\n\",\n        \"\\n\",\n        \"for key in dict_a.keys():\\n\",\n        \"    print(f\\\"value of {key} is {dict_a[key]}\\\" )\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\"\n        },\n        \"id\": \"AlDQq6itrBow\",\n        \"outputId\": \"4cfed042-ded2-4e65-e152-cccfbb9d198f\"\n      },\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"name\": \"stdout\",\n          \"text\": [\n            \"21\\n\"\n          ]\n        }\n      ],\n      \"source\": [\n        \"# sump up elements in a given matrix\\n\",\n        \"\\n\",\n        \"x = np.array([[1, 2, 3], [4, 5, 6]])\\n\",\n        \"n, m = x.shape\\n\",\n        \"s = 0\\n\",\n        \"for i in range(n):\\n\",\n        \"    for j in range(m):\\n\",\n        \"        s += x[i, j]\\n\",\n        \"\\n\",\n        \"print(s)\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\"\n        },\n        \"id\": \"_9z7HP1jrhOc\",\n        \"outputId\": \"c9efbc2f-3f4f-47d9-b378-55ceaf0b808f\"\n      },\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"name\": \"stdout\",\n          \"text\": [\n            \"Fibonacci Series are:\\n\",\n            \"1 :  1\\n\",\n            \"2 :  1\\n\",\n            \"3 :  2\\n\",\n            \"4 :  3\\n\",\n            \"5 :  5\\n\",\n            \"6 :  8\\n\",\n            \"7 :  13\\n\",\n            \"8 :  21\\n\",\n            \"9 :  34\\n\",\n            \"10 :  55\\n\"\n          ]\n        }\n      ],\n      \"source\": [\n        \"print(\\\"Fibonacci Series are:\\\")\\n\",\n        \"a = 1\\n\",\n        \"b = 1\\n\",\n        \"i = 3\\n\",\n        \"\\n\",\n        \"print(1, \\\": \\\",a)\\n\",\n        \"print(2, \\\": \\\",b)\\n\",\n        \"\\n\",\n        \"while i <= 10:\\n\",\n        \"    c = a + b\\n\",\n        \"    print(i, \\\": \\\", c)\\n\",\n        \"    a = b\\n\",\n        \"    b = c\\n\",\n        \"    i +=1\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\"\n        },\n        \"id\": \"hPsreJgAsK_p\",\n        \"outputId\": \"d5fd52b2-2329-483d-dbb6-76fe13d849c2\"\n      },\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"name\": \"stdout\",\n          \"text\": [\n            \"[0, 1, 4, 9, 16]\\n\"\n          ]\n        }\n      ],\n      \"source\": [\n        \"x = range(5)\\n\",\n        \"y = []\\n\",\n        \"\\n\",\n        \"for i in x:\\n\",\n        \"    y.append(i**2)\\n\",\n        \"\\n\",\n        \"print(y)\\n\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\"\n        },\n        \"id\": \"6JcMxjgwxIRn\",\n        \"outputId\": \"afe8ebeb-bf39-4460-c63f-f2facb7d1d20\"\n      },\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"name\": \"stdout\",\n          \"text\": [\n            \"1000\\n\"\n          ]\n        }\n      ],\n      \"source\": [\n        \"y = 0\\n\",\n        \"for i in range(1000):\\n\",\n        \"    for j in range(1000):\\n\",\n        \"        if i == j:\\n\",\n        \"            y += 1\\n\",\n        \"\\n\",\n        \"print(y)\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"IrFYj4J_xdnM\"\n      },\n      \"source\": [\n        \"11. Recursion\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\"\n        },\n        \"id\": \"OkS6ZtT1xgQA\",\n        \"outputId\": \"c12bd5f9-f468-46be-f9e4-d008283ab64a\"\n      },\n      \"outputs\": [\n        {\n          \"output_type\": \"execute_result\",\n          \"data\": {\n            \"text/plain\": [\n              \"720\"\n            ]\n          },\n          \"metadata\": {},\n          \"execution_count\": 8\n        }\n      ],\n      \"source\": [\n        \"def factorial(n):\\n\",\n        \"    if n == 1: # Base cases!\\n\",\n        \"        return 1\\n\",\n        \"    else: # Recursive step\\n\",\n        \"        return n * factorial(n - 1) # Recursive call\\n\",\n        \"\\n\",\n        \"factorial(6)\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\"\n        },\n        \"id\": \"j39q8TiWxzI8\",\n        \"outputId\": \"4d52aa0e-4edb-407a-b327-f42c0ae8ce0a\"\n      },\n      \"outputs\": [\n        {\n          \"output_type\": \"execute_result\",\n          \"data\": {\n            \"text/plain\": [\n              \"55\"\n            ]\n          },\n          \"metadata\": {},\n          \"execution_count\": 9\n        }\n      ],\n      \"source\": [\n        \"def fibonacci(n):\\n\",\n        \"    if n == 1: # first base case\\n\",\n        \"        return 1\\n\",\n        \"    elif n == 2: # second base case\\n\",\n        \"        return 1\\n\",\n        \"    else: # Recursive step\\n\",\n        \"        return fibonacci(n-1) + fibonacci(n-2) # Recursive call\\n\",\n        \"\\n\",\n        \"fibonacci(10)\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\"\n        },\n        \"id\": \"aLkvkAVsyrR9\",\n        \"outputId\": \"caddd5f4-3695-4ac6-d0c7-bdf2e0a51a0a\"\n      },\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"name\": \"stdout\",\n          \"text\": [\n            \"1\\n\",\n            \"1\\n\",\n            \"2\\n\",\n            \"3\\n\",\n            \"5\\n\",\n            \"8\\n\",\n            \"13\\n\",\n            \"21\\n\",\n            \"34\\n\",\n            \"55\\n\",\n            \"89\\n\",\n            \"144\\n\",\n            \"233\\n\",\n            \"377\\n\",\n            \"610\\n\",\n            \"987\\n\",\n            \"1597\\n\",\n            \"2584\\n\",\n            \"4181\\n\",\n            \"6765\\n\"\n          ]\n        }\n      ],\n      \"source\": [\n        \"def iter_fib(n):\\n\",\n        \"    fib = np.ones(n)\\n\",\n        \"\\n\",\n        \"    for i in range(2, n):\\n\",\n        \"        fib[i] = fib[i - 1] + fib[i-2]\\n\",\n        \"    return fib\\n\",\n        \"\\n\",\n        \"# save the series into an array\\n\",\n        \"fib_series = iter_fib(20)\\n\",\n        \"\\n\",\n        \"for i in range(np.size(fib_series)):\\n\",\n        \"    print(np.int64(fib_series[i]))\\n\",\n        \"\\n\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\"\n        },\n        \"id\": \"fwoSZXa5Cot1\",\n        \"outputId\": \"38cde0c8-269f-42e3-d77a-6d09ba02dcb6\"\n      },\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"name\": \"stdout\",\n          \"text\": [\n            \"1.0\\n\",\n            \"1.0\\n\",\n            \"1.0\\n\",\n            \"2.0\\n\",\n            \"1.5\\n\",\n            \"1.6666666666666667\\n\",\n            \"1.6\\n\",\n            \"1.625\\n\",\n            \"1.6153846153846154\\n\",\n            \"1.619047619047619\\n\",\n            \"1.6176470588235294\\n\",\n            \"1.6181818181818182\\n\",\n            \"1.6179775280898876\\n\",\n            \"1.6180555555555556\\n\",\n            \"1.6180257510729614\\n\",\n            \"1.6180371352785146\\n\",\n            \"1.618032786885246\\n\",\n            \"1.618034447821682\\n\",\n            \"1.6180338134001253\\n\",\n            \"1.618034055727554\\n\"\n          ]\n        }\n      ],\n      \"source\": [\n        \"def golden_ratio(n):\\n\",\n        \"    fib = np.ones(n)\\n\",\n        \"    golden = np.ones(n)\\n\",\n        \"\\n\",\n        \"    for i in range(2, n):\\n\",\n        \"        fib[i] = fib[i - 1] + fib[i-2]\\n\",\n        \"        golden[i] = fib[i - 1]/fib[i - 2]\\n\",\n        \"    return golden\\n\",\n        \"\\n\",\n        \"\\n\",\n        \"golden_series = golden_ratio(20)\\n\",\n        \"\\n\",\n        \"for i in range(np.size(golden_series)):\\n\",\n        \"    print(golden_series[i])\\n\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"eRtXuaqM1g1e\"\n      },\n      \"source\": [\n        \"12. **Towers of Hanoi**\\n\",\n        \"\\n\",\n        \" *The Towers of Hanoi problem consists of three vertical rods, or towers, and N disks of different sizes, each with a hole in the center so that the rod can slide through it. The disks are originally stacked on one of the towers in order of descending size (i.e., the largest disc is on the bottom). The goal of the problem is to move all the disks to a different rod while complying with the following three rules:*\\n\",\n        \"\\n\",\n        \"\\n\",\n        \"*   Only one disk can be moved at a time.\\n\",\n        \"*   Only the disk at the top of a stack may be moved.\\n\",\n        \"*   A disk may not be placed on top of a smaller disk.\\n\",\n        \"\\n\",\n        \"The following figure shows the steps of the solution to the Tower of Hanoi problem with three disks.\\n\",\n        \"\\n\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\"\n        },\n        \"id\": \"rqd_YjYT2XxN\",\n        \"outputId\": \"61e201a7-c1e5-4ee8-d26a-bb63f0f008f1\"\n      },\n      \"outputs\": [\n        {\n          \"name\": \"stdout\",\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"Move disk 1 from tower Start  to tower Goal  \\n\",\n            \"Move disk 2 from tower Start  to tower Middle\\n\",\n            \"Move disk 1 from tower Goal   to tower Middle\\n\",\n            \"Move disk 3 from tower Start  to tower Goal  \\n\",\n            \"Move disk 1 from tower Middle to tower Start \\n\",\n            \"Move disk 2 from tower Middle to tower Goal  \\n\",\n            \"Move disk 1 from tower Start  to tower Goal  \\n\"\n          ]\n        }\n      ],\n      \"source\": [\n        \"def hanoi_towers(N, Start, Goal, Middle):\\n\",\n        \"\\n\",\n        \"    if N != 0:\\n\",\n        \"        # recursive call that moves N-1 stack from starting tower\\n\",\n        \"        # to the middle tower\\n\",\n        \"\\n\",\n        \"        hanoi_towers(N-1, Start, Middle, Goal)\\n\",\n        \"        # The movement of the bottom disk from starting tower to final tower\\n\",\n        \"        print(f\\\"Move disk {N} from tower {Start} to tower {Goal}\\\")\\n\",\n        \"\\n\",\n        \"        # recursive call that moves N-1 stack from middle tower\\n\",\n        \"        # to the goal tower\\n\",\n        \"        hanoi_towers(N-1, Middle, Goal, Start)\\n\",\n        \"\\n\",\n        \"\\n\",\n        \"hanoi_towers(3, \\\"Start \\\", \\\"Goal  \\\", \\\"Middle\\\")\"\n      ]\n    }\n  ],\n  \"metadata\": {\n    \"colab\": {\n      \"provenance\": [],\n      \"authorship_tag\": \"ABX9TyMdwazc1o2yBOJiWFEa++Ka\",\n      \"include_colab_link\": true\n    },\n    \"kernelspec\": {\n      \"display_name\": \"Python 3\",\n      \"name\": \"python3\"\n    },\n    \"language_info\": {\n      \"name\": \"python\"\n    }\n  },\n  \"nbformat\": 4,\n  \"nbformat_minor\": 0\n}",
            "linked_to": [],
            "source": "external_search",
            "confidence": 70,
            "last_verified": "2025-08-25T02:33:31.260715"
        },
        "self_built_algorithm_define_variable": {
            "type": "define",
            "value": "\n# A self-generated algorithm for defining a variable.\n# Discovered concept: Failed to derive an abstract concept.\nmy_number = 13\nprint(f\"تم إنشاء متغير: {var_name} بقيمة {repr(var_value)}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T04:37:43.430461"
        },
        "self_built_algorithm_simple_addition_function": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple function.\n# Discovered concept: **تحليل المقتطف:**\nالمقتطف المقدم ليس كود بايثون. إنه وثيقة \"What's New\" أو سجل التغييرات (Changelog) لمشروع برمجي يسمى \"Eggdrop\". يقوم هذا المستند بتفصيل التغييرات، الميزات الجديدة، إصلاحات الأخطاء، وتحديثات المكونات المختلفة بين إصدارات البرنامج، مثل 1.10.0 و 1.10.1. إنه بمثابة وثائق للمستخدمين والمطورين لفهم التطورات في البرنامج.\n\n**المفهوم:**\n`A document detailing changes and new features between software versions.`\ndef add_two_numbers(a, b):\n    return a + b\nresult = add_two_numbers(3, 9)\nprint(f\"ناتج جمع 3 و 9 هو: {result}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:15:19.811458"
        },
        "self_built_algorithm_check_data_type": {
            "type": "check",
            "value": "\n# A self-generated algorithm to check data type.\n# Discovered concept: المفهوم: `Demonstrating and verifying code behavior using assertions within structured examples.`\ndata_item = [1, 2]\ndata_type = type(data_item).__name__\nprint(f\"نوع البيانات لـ {repr(data_item)} هو: {data_type}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:16:24.116390"
        },
        "self_built_algorithm_for_loop_1_to_5": {
            "type": "for",
            "value": "\n# A self-generated algorithm for a loop.\n# Discovered concept: الكود المقدم ليس كود بايثون، بل هو نص وصفي عن منصة Ergo blockchain، على الأرجح بتنسيق Markdown. ولذلك، لا يمكن تحليل مفهوم برمجي أساسي يمثله هذا النص.\nfor i in range(1, 5 + 1):\n    print(f\"العدد الحالي: {i}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T04:52:35.229997"
        },
        "self_built_algorithm_polymorphism_example": {
            "type": "polymorphism",
            "value": "\n# A self-generated algorithm for polymorphism.\n# Discovered concept: نموذج برمجي يقوم بهيكلة الكود حول الكائنات، مغلفاً البيانات والدوال التي تعمل عليها لتحقيق النمطية وإعادة الاستخدام.\nclass Animal:\n    def speak(self):\n        return \"I am an animal.\"\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\nfor animal in [Dog(), Cat()]:\n    print(animal.speak())\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:15:32.827451"
        },
        "self_built_algorithm_create_class_with_inheritance": {
            "type": "create",
            "value": "\n# A self-generated algorithm for class inheritance.\n# Discovered concept: - المفهوم: `A programming paradigm that organizes code into reusable, self-contained objects by combining data and their associated functionality.`\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n    def speak(self):\n        raise NotImplementedError(\"Subclass must implement abstract method\")\nclass Dog(Animal):\n    def __init__(self, name):\n        super().__init__(name)\n    def speak(self):\n        return f\"{self.name} makes a sound.\"\nmy_dog = Dog(\"Buddy\")\nprint(f\"The {my_dog.__class__.__name__} says: {my_dog.speak()}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T04:55:27.469111"
        },
        "self_built_algorithm_if_statement": {
            "type": "if",
            "value": "\n# A self-generated algorithm for a conditional statement.\n# Discovered concept: برمجة قائمة على الكائنات لتعريف تدفق عمل (workflow) من خلال تجميع كائنات الإجراءات القابلة للتكوين.\nmy_number = 78\nif my_number > 50:\n    print(\"الرقم أكبر من 50.\")\nelse:\n    print(\"الرقم ليس أكبر من 50.\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T04:55:52.763904"
        },
        "self_built_algorithm_simple_stack_operation": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple stack.\n# Discovered concept: - الكود: `def factorial(n):\n    if n == 0: return 1\n    else: return n * factorial(n-1)`\n- المفهوم: `A function that calls itself to solve smaller versions of the same problem.`\n- الكود: `# -*- coding: utf-8 -*-\n\"\"\"Homework_6_Counting_Stacks_and_Queues.ipynb\n\nAutomatically generated by Colaboratory.\n\nOriginal file is located at\n    https://colab.research.google.com/drive/1BWlHvhjFF7ryA9AvFBmNvlVdXQPhvuHY\n\nBefore you turn this problem in, make sure everything runs as expected. First, **restart the kernel** (in the menubar, select Kernel$\\rightarrow$Restart) and then **run all cells** (in the menubar, select Cell$\\rightarrow$Run All).\n\nMake sure you fill in any place that says `YOUR CODE HERE` or \"YOUR ANSWER HERE\", as well as your name and collaborators below:\n\"\"\"\n\nNAME = \"Yash Sharma\"\nCOLLABORATORS = \"\"\n\n\"\"\"---\n\n# Homework 6: Counting Stacks and Queues\n### Copyright Luca de Alfaro, 2019-21.  License: CC-BY-NC.\n\n## Submission\n\n* Download the .ipynb file:\n\n    File > Download .ipynb\n    \n    \n* Then, [submit the .ipynb to this Google Form](https://docs.google.com/forms/d/e/1FAIpQLSfLkUHsZ4UcLnf4OboFsRkf7tzumSczC3WjU5vpj5VcXBlmOA/viewform?usp=sf_link).\n\n## About this homework\n\nTwo things are new about this homework assignment. \n\nFirst, this homework is graded using `assert`, which is the standard way in Python of asking for something to be True.  So, a cell succeeds if no error is raised; you no longer see \"Success\" printed out all the time. \n\nSecond, there are essentially no hidden tests: rather, we make sure your implementation works by comparing your implementation with a reference one.  Precisely, we will be comparing the implementation of CountingQueue with that of Queue.\n\n## Stacks, Queues, and Their Counting Versions\n\nA stack is a data structure with two operations: push, and pop.  Picture it as a pile of dishes sitting on a counter.  A push operation places a dish on top of the pile.  A pop operation returns the dish on top of the pile, or None if the pile is empty, that is, contains no dishes.  A \"dish\" can be any Python object. \n\nA queue is a data structure with two operations: put, and get.  Imagine it as a stack of books horizontally on a shelf.  A put operation adds the book to the left end of the books on the shelf; a get operation gets the book from the right end of the shelf.  \n\nThus, the difference between a stack and a queue is that the stack is FILO (First In, Last Out), whereas the queue is FIFO (First In, First Out).  Elements in a stack are retrieved newest first. \nElements in a queue are retrieved in the order they were put in, oldest first.\n\nWe will implement here these data structures, with a small twist: we will also introduce _counting_ versions of them, which avoid keeping multiple identical copies of objects in a row.\n\nLet us begin by implementing a plain vanilla stack.\n\"\"\"\n\nclass Stack(object):\n\n    def __init__(self):\n        self.stack = []\n\n    def __repr__(self):\n        \"\"\"Defining a __repr__ function will enable us to print the\n        stack contents, and facilitate debugging.\"\"\"\n        return repr(self.stack) # Good enough.\n\n    def push(self, x):\n        \"\"\"The \"top\" of the stack is the end of the list.\"\"\"\n        self.stack.append(x)\n\n    def pop(self):\n        return self.stack.pop() if len(self.stack) > 0 else None\n\n    def isempty(self):\n        return len(self.stack) == 0\n    \n    def __len__(self):\n        return len(self.stack)\n    \n    def __iter__(self):\n        for el in self.stack:\n            yield el\n            \n    def __getitem__(self, i):\n        return self.stack[i]\n    \n    def __contains__(self, x):\n        return x in self.stack\n\n\"\"\"Let's see how this works.\"\"\"\n\ns = Stack()\nprint(s.pop())\ns.push('a')\ns.push('b')\nprint(s.pop())\nprint(s.pop())\nprint(s.pop())\n\n\"\"\"Ok!  The definition of a queue is similar. \"\"\"\n\nclass Queue(object):\n\n    def __init__(self):\n        self.queue = []\n\n    def __repr__(self):\n        \"\"\"Defining a __repr__ function will enable us to print the\n        queue contents, and facilitate debugging.\"\"\"\n        return repr(self.queue) # Good enough.\n\n    def add(self, x):\n        self.queue.append(x)\n\n    def get(self):\n        # This is the only difference compared to the stack above.\n        return self.queue.pop(0) if len(self.queue) > 0 else None\n\n    def isempty(self):\n        return len(self.queue) == 0\n    \n    def __len__(self):\n        return len(self.queue)\n    \n    def __iter__(self):\n        for el in self.queue:\n            yield el\n            \n    def __getitem__(self, i):\n        return self.queue[i]\n    \n    def __contains__(self, x):\n        return x in self.queue\n\n\"\"\"Let's see how it works. \"\"\"\n\ns = Queue()\nprint(s.get())\ns.add('a')\ns.add('b')\nprint(s.get())\nprint(s.get())\nprint(s.get())\n\n\"\"\"As you see, in a queue, the elements are retrieved in the same order in which they were added.\n\nPython experts might note that, for a queue, we would do better by using the [`collections.deque` class](https://docs.python.org/3.7/library/collections.html#collections.deque), rather than the list class, to make the `pop(0)` operation more efficient; in lists, it takes time proportional to the length of the list; in deques, it takes constant time.  For small lists, however, the difference is negligible.\n\nWe now consider a use case in which we may need to put in the queue or stack many repeated copies of the same object.  For instance, assume that the queue is used to store events, and assume that some event may end up being repeated many times in a row.  As an example, the events can be \"s\", for the tick of a second, \"m\", when the minute advances, and \"h\", when the hour advances.  There will be 60 consecutive \"s\" events between any two \"m\" events, and it seems a waste to store so many consecutive identical events.  Storing many identical things in a row is akin to counting in unary notation, after all.  We would be better off storing the repeated elements only once, along with a count of the number of times they occur.  Let's develop a queue using this idea (a stack can be done similarly).\n\"\"\"\n\nclass CountingQueue(object):\n\n    def __init__(self):\n        self.queue = []\n\n    def __repr__(self):\n        return repr(self.queue)\n\n    def add(self, x, count=1):\n        # If the element is the same as the last element, we simply\n        # increment the count.  This assumes we can test equality of\n        # elements.\n        if len(self.queue) > 0:\n            xx, cc = self.queue[-1]\n            if xx == x:\n                self.queue[-1] = (xx, cc + count)\n            else:\n                self.queue.append((x, count))\n        else:\n            self.queue = [(x, count)]\n\n    def get(self):\n        if len(self.queue) == 0:\n            return None\n        x, c = self.queue[0]\n        if c == 1:\n            self.queue.pop(0)\n            return x\n        else:\n            self.queue[0] = (x, c - 1)\n            return x\n\n    def isempty(self):\n        # Since the count of an element is never 0, we can just check\n        # whether the queue is empty.\n        return len(self.queue) == 0\n\n\"\"\"Let's put this to the same test as before, printing the queue contents at each step to see what is going on.\"\"\"\n\nq = CountingQueue()\nq.add('a')\nprint(q)\nq.add('b', count=5)\nprint(q)\nq.add('c', count=2)\nprint(q)\nwhile not q.isempty():\n    print(q.get())\n    print(q)\n\n\"\"\"It works!  And notice that it works even if we add elements one by one.\"\"\"\n\nq = CountingQueue()\nfor i in range(10):\n    q.add('a')\nq.add('b')\nfor i in range(3):\n    q.add('c', count=2)\nprint(q)\n\n\"\"\"## The Homework Assignment\n\nFor this homework, you must implement the following methods for `CountingQueue`: \n\n* `__len__`\n* `__iter__`\n* `__in__`\n* `__getitem__`\n\nYour goal is to have `CountingQueue` behave exactly like `Queue` to an outside user: the objects have to be different only due to their internal implementation.  So for instance, `__len__` must return the number of elements, including repetitions; not the number of (element, count) pairs in `self.queue`. \n\nNote that we are adding methods to a class that has already been defined, so our definition have the following somewhat unusual form: \n\"\"\"\n\ndef counting_queue_peek(self):\n    if len(self.queue) == 0:\n        return None\n    el, _ = self.queue[0]\n    return el\n\nCountingQueue.peek = counting_queue_peek\n\n\"\"\"In other words, we first create a function (in this case `counting_queue_peek`) and then we assign it to the method `peek` of `CountingQueue`.  It's a bit unusual, but it works, and it relieves us from the task of redefining the class each time we need a new method. \"\"\"\n\nq = CountingQueue()\nq.add(\"cat\")\nq.add(\"dog\")\nq.peek()\n\n\"\"\"### `__len__`\"\"\"\n\ndef counting_queue_len(self):\n\n    if len(self.queue) == 0:\n        return len(self.queue)\n    else:\n        pass\n    count = 0\n    for i in self.queue:\n        l, r = i\n        count += r\n    return count\n\nCountingQueue.__len__ = counting_queue_len\n\n# 5 points.  Simple tests\n\nq = CountingQueue()\nassert len(q) == 0\nq.add(\"cat\")\nq.add(\"dog\")\nassert len(q) == 2\n\n# 5 points.  More complicated tests. \n\nq = CountingQueue()\nassert len(q) == 0\nq.add(\"cat\")\nq.add(\"cat\")\nassert len(q.queue) == 1\nassert len(q) == 2\nq.add(\"dog\")\nassert len(q) == 3\nassert len(q.queue) == 2\nq.add(\"dog\")\nassert len(q) == 4\nassert len(q) == 4 # Hey, just in case you went for the quantum-mechanical solution ;-) \nassert len(q) == 4\nassert len(q.queue) == 2\n\n# 5 points.  Works same as Queue. \n\nimport random \n\nfor k in range(100):\n    q0 = Queue()\n    q1 = CountingQueue()\n    for _ in range(100):\n        el = random.choice([\"a\", \"b\", \"c\"])\n        q0.add(el)\n        q1.add(el)\n        assert len(q0) == len(q1)\n        assert len(q0.queue) >= len(q1.queue)\n\n\"\"\"### `__iter__`\"\"\"\n\ndef counting_queue_iter(self):\n    for i in self.queue:\n        l, r = i\n        for x in range(r):\n            yield(l)\nCountingQueue.__iter__ = counting_queue_iter\n\n# 5 points.  Simple tests. \n\nq = CountingQueue()\nq.add(\"cat\", count=2)\nq.add(\"dog\", count=3)\nassert [x for x in q] == [\"cat\"] * 2 + [\"dog\"] * 3\n\n# 5 points.  Works the same as queue. \n\nfor k in range(100):\n    q0 = Queue()\n    q1 = CountingQueue()\n    for _ in range(100):\n        el = random.choice([\"a\", \"b\", \"c\"])\n        q0.add(el)\n        q1.add(el)\n        assert [x for x in q0] == [x for x in q1]\n\n\"\"\"### `__in__`\"\"\"\n\ndef counting_queue_in(self, el):\n    ### YOUR CODE HERE\n    pass\nCountingQueue.__in__ = counting_queue_in\n\n# 5 points.  Simple cases. \n\nq = CountingQueue()\nassert \"cat\" not in q\nq.add(\"cat\", count=2)\nassert \"cat\" in q\nassert \"dog\" not in q\nq.add(\"dog\")\nassert \"cat\" in q\nassert \"dog\" in q\nq.get()\nassert \"cat\" in q\nassert \"dog\" in q\nq.get()\nassert \"cat\" not in q\nassert \"dog\" in q\nq.get()\nassert \"cat\" not in q\nassert \"dog\" not in q\n\n# 5 points.  Behaves the same as Queue. \n\nelements = range(5)\nfor k in range(100):\n    q0 = Queue()\n    q1 = CountingQueue()\n    for _ in range(20):\n        el = random.choice(elements)\n        q0.add(el)\n        q1.add(el)\n        for x in elements:\n            assert (x in q0) == (x in q1)\n\n\"\"\"### `__getitem__`\"\"\"\n\ndef counting_queue_getitem(self, n):\n    if n >= len(self) or n < 0:\n        raise IndexError\n    if type(n) != int:\n        raise TypeError\n    ind = 0\n    for i in self.queue:\n        l, r = i\n        for i in range(r):  \n            if n == ind:\n                return l\n            ind += 1\nCountingQueue.__getitem__ = counting_queue_getitem\n\n# 5 points: simple tests. \n\nq = CountingQueue()\nq.add(\"cat\", count=2)\nq.add(\"dog\", count=3)\nq.add(\"bird\", count=4)\nels = [q[i] for i in range(9)]\nassert els == ['cat'] * 2 + ['dog'] * 3 + ['bird'] * 4\n# Let's do it again. \nels = [q[i] for i in range(9)]\nassert els == ['cat'] * 2 + ['dog'] * 3 + ['bird'] * 4\n\n# 5 points: you raise IndexError when accessing elements out of bounds. \n\nq = CountingQueue()\nq.add(\"cat\", count=2)\nq.add(\"dog\", count=3)\n\n# Raise IndexError when it's too high... \ntry:\n    q[5]\n    assert False, \"Failed to raise IndexError\"\nexcept IndexError:\n    pass\nassert q[4] == \"dog\"\ntry:\n    q[5]\n    assert False, \"Failed to raise IndexError\"\nexcept IndexError:\n    pass\n\n# And also when it's too low. \ntry:\n    q[-1]\n    assert False, \"Failed to raise IndexError\"\nexcept IndexError:\n    pass\n\n# And raise TypeError if you try to index with a non-integer. \ntry:\n    q[\"hello\"]\n    assert False, \"Failed to raise TypeError\"\nexcept TypeError:\n    pass\n\n# 5 points.  Behaves the same as Queue. \n\nelements = range(3)\nfor k in range(100):\n    q0 = Queue()\n    q1 = CountingQueue()\n    for m in range(40):\n        el = random.choice(elements)\n        q0.add(el)\n        q1.add(el)\n        for i in range(m):\n            assert q0[i] == q1[i]`\n- المفهوم: `A data structure that internally represents consecutive identical items with a single item and a count, maintaining a standard external interface.`\nmy_stack = []\nprint(\"Adding items to the stack...\")\nfor i in range((5,)):\n    my_stack.append(i)\nprint(f\"Stack after adding items: {my_stack}\")\nprint(\"Removing items from the stack...\")\nwhile my_stack:\n    item = my_stack.pop()\n    print(f\"Popped item: {item}\")\nprint(f\"Stack after removing all items: {my_stack}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:10:15.480814"
        },
        "self_built_algorithm_run_threaded_task": {
            "type": "run",
            "value": "\n# A self-generated algorithm for concurrency.\n# Discovered concept: يبدو أن هناك تداخلاً هنا، حيث أن الكود المقدم هو بلغة Go وليس بايثون كما هو مذكور في التعليمات. سأقوم بتحليل كود Go المقدم.\n\n- الكود: (الكود المقدم بلغة Go)\n- المفهوم: `Setting up a basic web server to handle HTTP requests and generate responses.`\n(إعداد خادم ويب أساسي لمعالجة طلبات HTTP وتوليد الاستجابات.)\nimport threading\ndef task(name):\n    print(f\"Task {name} started.\")\n    time.sleep(random.uniform(0.5, 1.5))\n    print(f\"Task {name} finished.\")\nprint(\"Starting concurrent tasks...\")\nt1 = threading.Thread(target=task, args=(\"task1\",))\nt2 = threading.Thread(target=task, args=(\"task2\",))\nt1.start()\nt2.start()\nt1.join()\nt2.join()\nprint(\"All tasks are done.\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:17:34.571478"
        },
        "self_built_algorithm_simple_http_request": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple HTTP request.\n# Discovered concept: - الكود: (النص المقدم)\n- المفهوم: `A structured outline of open-source projects seeking mentored student contributions.`\nimport requests\ndef fetch_url(url):\n    try:\n        response = requests.get(url, timeout=5)\n        print(f\"Successfully fetched {url}. Status Code: {response.status_code}\")\n    except requests.exceptions.RequestException as e:\n        print(f\"Failed to fetch {url}. Error: {e}\")\nfetch_url(\"https://example.com\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:16:11.526963"
        },
        "self_built_algorithm_create_simple_hashmap": {
            "type": "create",
            "value": "\n# A self-generated algorithm for a hash map (dictionary).\n# Discovered concept: **ملاحظة هامة:** الكود المقدم ليس بايثون بل هو **برنامج نصي لـ Bash (Bash script)**. سأقوم بتحليله على هذا الأساس.\n\n-   **الكود:** (تم توفيره أعلاه)\n-   **المفهوم:** `Automating the execution and testing of code examples across multiple programming languages based on their system availability.`\nmy_dict = {}\nmy_dict[\"fruit_1\"] = \"apple\"\nmy_dict[\"fruit_2\"] = \"banana\"\nprint(f\"My dictionary: {my_dict}\")\nprint(f\"Value for 'fruit_1': {my_dict.get('fruit_1')}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:14:41.660188"
        },
        "self_built_algorithm_test_function_example": {
            "type": "test",
            "value": "\n# A self-generated algorithm for a simple test case.\n# Discovered concept: المفهوم: `The documented evolution of a software project through successive versions.`\ndef add(a, b):\n    return a + b\ndef run_test(func, *args, expected_result):\n    actual_result = func(*args)\n    if actual_result == expected_result:\n        print(f\"Test for {func.__name__} passed! Expected: {expected_result}, Got: {actual_result}\")\n    else:\n        print(f\"Test for {func.__name__} FAILED! Expected: {expected_result}, Got: {actual_result}\")\nrun_test(add, 2, 3, expected_result=5)\nrun_test(add, 1, 1, expected_result=3)\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:14:54.214201"
        },
        "self_built_algorithm_git_commit": {
            "type": "git",
            "value": "\n# A self-generated algorithm for version control.\n# Discovered concept: المفهوم: `A comprehensive set of guidelines and practices for developing high-quality, maintainable, and readable Python software.`\ndef git_commit_simulation(message):\n    print(f'\\n>>>>> simulating git commit -m \"{message}\"')\n    print(\"...processing changes...\")\n    print(\"...packaging files...\")\n    print(\"...creating new snapshot...\")\n    print(f\"Commit with message '{message}' successfully created.\")\n    \ngit_commit_simulation(\"first_commit\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:12:25.631022"
        },
        "self_built_algorithm_find_bug": {
            "type": "find",
            "value": "\n# A self-generated algorithm for debugging.\n# Discovered concept: يبدو أن النص الذي قدمته ليس مقتطف كود بايثون، بل هو سجل تغييرات (Changelog) لمشروع برنامج يدعى `xboxdrv`.\n\nالمفهوم: `A chronological log of changes, fixes, and new features in a software's version history.`\ndef find_bug_simulation(error):\n    print(f'\\n>>>>> simulating debugging for error: \"{error}\"')\n    print(\"...checking syntax...\")\n    print(\"...reviewing logical flow...\")\n    print(f\"Potential fix found for '{error}': Check variable assignments.\")\n    \nfind_bug_simulation(\"syntax_error\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:13:54.931372"
        },
        "self_built_algorithm_create_simple_object": {
            "type": "create",
            "value": "\n# A self-generated algorithm for creating an object from a class.\n# Discovered concept: المقتطف المقدم ليس مقتطف كود بايثون بالمعنى التقليدي (مثل دالة أو كلاس)، بل هو **سجل تغييرات (Changelog)** أو ملاحظات إصدار لمكتبة بايثون تسمى `fido2`.\n\n- المفهوم: `A chronological record of changes, new features, and bug fixes across a software project's versions.`\nclass Car:\n    def __init__(self, color):\n        self.color = color\nmy_car = Car(\"أحمر\")\nprint(f\"تم إنشاء كائن جديد من {my_car.__class__.__name__} بلون {my_car.color}.\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:13:12.016082"
        },
        "self_built_algorithm_linear_search": {
            "type": "linear",
            "value": "\n# A self-generated algorithm for linear search.\n# Discovered concept: A nested data structure for organizing related information using key-value pairs.\ndef linear_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\ndata = [10, 20, 30, 40, 50]\nitem_to_find = 20\nresult_index = linear_search(data, item_to_find)\nif result_index != -1:\n    print(f\"تم العثور على العنصر {item_to_find} في الفهرس: {result_index}\")\nelse:\n    print(f\"العنصر {item_to_find} غير موجود في القائمة.\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:15:45.520749"
        },
        "self_built_algorithm_factorial_recursion": {
            "type": "factorial",
            "value": "\n# A self-generated algorithm using recursion.\n# Discovered concept: A function calls itself to solve a problem, with a clear base case to stop.\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\nnumber = 7\nresult = factorial(number)\nprint(f\"مضروب الرقم {number} هو: {result}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:16:48.922049"
        },
        "self_built_algorithm_simple_bubble_sort": {
            "type": "simple",
            "value": "\n# A self-generated algorithm for a simple bubble sort.\n# Discovered concept: Implement sorting by iterating and swapping adjacent elements in a list.\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\nmy_list = [20, 17, 45, 16, 40]\nsorted_list = bubble_sort(my_list)\nprint(f\"القائمة الأصلية: {my_list}\")\nprint(f\"القائمة بعد الفرز: {sorted_list}\")\n",
            "linked_to": [],
            "source": "unsupervised_learning",
            "confidence": 99,
            "last_verified": "2025-08-25T05:15:07.420724"
        }
    },
    "meta_rules": {
        "data_structures": {
            "type": "data_structures",
            "blueprint": "Use dictionary comprehension to create dictionaries from iterables."
        },
        "control_flow": {
            "type": "control_flow",
            "blueprint": "Use a `for` loop with `range` to iterate a specific number of times."
        },
        "function_definition": {
            "type": "function_definition",
            "blueprint": "Define a function with a `def` keyword, parameters, and a `return` statement."
        },
        "simple_arithmetic": {
            "type": "simple_arithmetic",
            "blueprint": "Perform simple mathematical operations (+, -, *, /) to find relationships between numbers."
        },
        "sorting_algorithm": {
            "type": "sorting_algorithm",
            "blueprint": "Implement sorting by iterating and swapping adjacent elements in a list."
        },
        "recursion": {
            "type": "recursion",
            "blueprint": "A function calls itself to solve a problem, with a clear base case to stop."
        },
        "file_handling": {
            "type": "file_handling",
            "blueprint": "Use `with open(...) as f:` to safely read from or write to a file."
        },
        "oop": {
            "type": "oop",
            "blueprint": "Define a `class` with an `__init__` method and attributes to create reusable objects."
        },
        "graph_theory": {
            "type": "graph_theory",
            "blueprint": "Use Breadth-First Search (BFS) to find the shortest path in an unweighted graph."
        },
        "string_processing": {
            "type": "string_processing",
            "blueprint": "Use built-in string methods like `.lower()`, `.split()` or regular expressions to analyze text."
        },
        "dynamic_programming": {
            "type": "dynamic_programming",
            "blueprint": "Break a problem into overlapping subproblems, solve each once, and store the result to avoid re-computation (memoization)."
        },
        "search_and_optimization": {
            "type": "search_and_optimization",
            "blueprint": "Use a priority queue and a heuristic function to find the optimal path in a weighted graph."
        },
        "dijkstra_pathfinding": {
            "type": "dijkstra_pathfinding",
            "blueprint": "Use a priority queue to find the shortest path in a weighted graph, prioritizing the lowest cost."
        },
        "prim_mst": {
            "type": "prim_mst",
            "blueprint": "Use a priority queue to build a Minimum Spanning Tree by greedily adding the smallest weight edge to a growing tree."
        },
        "kruskal_mst": {
            "type": "kruskal_mst",
            "blueprint": "Use a Disjoint Set Union (DSU) data structure to build a Minimum Spanning Tree by iterating through sorted edges."
        },
        "hanoi_towers": {
            "type": "hanoi_towers",
            "blueprint": {
                "name": "hanoi_towers_logic",
                "description": "To move N disks from source to destination, first move N-1 disks to an auxiliary tower, then move the last disk to the destination, and finally move the N-1 disks from the auxiliary tower to the destination.",
                "components": [
                    {
                        "step": 1,
                        "action": "move_disks",
                        "count": "n-1",
                        "from": "source",
                        "to": "auxiliary",
                        "using": "destination"
                    },
                    {
                        "step": 2,
                        "action": "move_disk",
                        "count": 1,
                        "from": "source",
                        "to": "destination"
                    },
                    {
                        "step": 3,
                        "action": "move_disks",
                        "count": "n-1",
                        "from": "auxiliary",
                        "to": "destination",
                        "using": "source"
                    }
                ]
            }
        },
        "variables": {
            "type": "variables",
            "blueprint": "Failed to derive an abstract concept."
        },
        "general": {
            "type": "general",
            "blueprint": "يبدو أن مقتطف الكود المقدم ليس رمز بايثون فعلي، بل هو سجل تغييرات (Changelog) لتطبيق محرر النصوص Geany. إنه يصف الميزات الجديدة، إصلاحات الأخطاء، والتحسينات التي تمت إضافتها في الإصدارات المختلفة من التطبيق.\n\nبناءً على ذلك، المفهوم البرمجي الأساسي الذي يمثله هذا النص (في سياق تطوير البرمجيات) هو:\n\n**التوثيق الزمني للتغييرات، الميزات الجديدة، وإصلاحات الأخطاء عبر إصدارات البرمجيات.**"
        },
        "functions": {
            "type": "functions",
            "blueprint": "**تحليل المقتطف:**\nالمقتطف المقدم ليس كود بايثون. إنه وثيقة \"What's New\" أو سجل التغييرات (Changelog) لمشروع برمجي يسمى \"Eggdrop\". يقوم هذا المستند بتفصيل التغييرات، الميزات الجديدة، إصلاحات الأخطاء، وتحديثات المكونات المختلفة بين إصدارات البرنامج، مثل 1.10.0 و 1.10.1. إنه بمثابة وثائق للمستخدمين والمطورين لفهم التطورات في البرنامج.\n\n**المفهوم:**\n`A document detailing changes and new features between software versions.`"
        },
        "data_types": {
            "type": "data_types",
            "blueprint": "المفهوم: `Demonstrating and verifying code behavior using assertions within structured examples.`"
        },
        "a_star_pathfinding": {
            "type": "a_star_pathfinding",
            "blueprint": "المفهوم: `Programmatically building and interacting with a physics simulation environment, including rigid bodies, soft bodies، والروبوتات.`"
        },
        "loops": {
            "type": "loops",
            "blueprint": "الكود المقدم ليس كود بايثون، بل هو نص وصفي عن منصة Ergo blockchain، على الأرجح بتنسيق Markdown. ولذلك، لا يمكن تحليل مفهوم برمجي أساسي يمثله هذا النص."
        },
        "polymorphism": {
            "type": "polymorphism",
            "blueprint": "نموذج برمجي يقوم بهيكلة الكود حول الكائنات، مغلفاً البيانات والدوال التي تعمل عليها لتحقيق النمطية وإعادة الاستخدام."
        },
        "inheritance": {
            "type": "inheritance",
            "blueprint": "- المفهوم: `A programming paradigm that organizes code into reusable, self-contained objects by combining data and their associated functionality.`"
        },
        "conditionals": {
            "type": "conditionals",
            "blueprint": "برمجة قائمة على الكائنات لتعريف تدفق عمل (workflow) من خلال تجميع كائنات الإجراءات القابلة للتكوين."
        },
        "stacks_and_queues": {
            "type": "stacks_and_queues",
            "blueprint": "- الكود: `def factorial(n):\n    if n == 0: return 1\n    else: return n * factorial(n-1)`\n- المفهوم: `A function that calls itself to solve smaller versions of the same problem.`\n- الكود: `# -*- coding: utf-8 -*-\n\"\"\"Homework_6_Counting_Stacks_and_Queues.ipynb\n\nAutomatically generated by Colaboratory.\n\nOriginal file is located at\n    https://colab.research.google.com/drive/1BWlHvhjFF7ryA9AvFBmNvlVdXQPhvuHY\n\nBefore you turn this problem in, make sure everything runs as expected. First, **restart the kernel** (in the menubar, select Kernel$\\rightarrow$Restart) and then **run all cells** (in the menubar, select Cell$\\rightarrow$Run All).\n\nMake sure you fill in any place that says `YOUR CODE HERE` or \"YOUR ANSWER HERE\", as well as your name and collaborators below:\n\"\"\"\n\nNAME = \"Yash Sharma\"\nCOLLABORATORS = \"\"\n\n\"\"\"---\n\n# Homework 6: Counting Stacks and Queues\n### Copyright Luca de Alfaro, 2019-21.  License: CC-BY-NC.\n\n## Submission\n\n* Download the .ipynb file:\n\n    File > Download .ipynb\n    \n    \n* Then, [submit the .ipynb to this Google Form](https://docs.google.com/forms/d/e/1FAIpQLSfLkUHsZ4UcLnf4OboFsRkf7tzumSczC3WjU5vpj5VcXBlmOA/viewform?usp=sf_link).\n\n## About this homework\n\nTwo things are new about this homework assignment. \n\nFirst, this homework is graded using `assert`, which is the standard way in Python of asking for something to be True.  So, a cell succeeds if no error is raised; you no longer see \"Success\" printed out all the time. \n\nSecond, there are essentially no hidden tests: rather, we make sure your implementation works by comparing your implementation with a reference one.  Precisely, we will be comparing the implementation of CountingQueue with that of Queue.\n\n## Stacks, Queues, and Their Counting Versions\n\nA stack is a data structure with two operations: push, and pop.  Picture it as a pile of dishes sitting on a counter.  A push operation places a dish on top of the pile.  A pop operation returns the dish on top of the pile, or None if the pile is empty, that is, contains no dishes.  A \"dish\" can be any Python object. \n\nA queue is a data structure with two operations: put, and get.  Imagine it as a stack of books horizontally on a shelf.  A put operation adds the book to the left end of the books on the shelf; a get operation gets the book from the right end of the shelf.  \n\nThus, the difference between a stack and a queue is that the stack is FILO (First In, Last Out), whereas the queue is FIFO (First In, First Out).  Elements in a stack are retrieved newest first. \nElements in a queue are retrieved in the order they were put in, oldest first.\n\nWe will implement here these data structures, with a small twist: we will also introduce _counting_ versions of them, which avoid keeping multiple identical copies of objects in a row.\n\nLet us begin by implementing a plain vanilla stack.\n\"\"\"\n\nclass Stack(object):\n\n    def __init__(self):\n        self.stack = []\n\n    def __repr__(self):\n        \"\"\"Defining a __repr__ function will enable us to print the\n        stack contents, and facilitate debugging.\"\"\"\n        return repr(self.stack) # Good enough.\n\n    def push(self, x):\n        \"\"\"The \"top\" of the stack is the end of the list.\"\"\"\n        self.stack.append(x)\n\n    def pop(self):\n        return self.stack.pop() if len(self.stack) > 0 else None\n\n    def isempty(self):\n        return len(self.stack) == 0\n    \n    def __len__(self):\n        return len(self.stack)\n    \n    def __iter__(self):\n        for el in self.stack:\n            yield el\n            \n    def __getitem__(self, i):\n        return self.stack[i]\n    \n    def __contains__(self, x):\n        return x in self.stack\n\n\"\"\"Let's see how this works.\"\"\"\n\ns = Stack()\nprint(s.pop())\ns.push('a')\ns.push('b')\nprint(s.pop())\nprint(s.pop())\nprint(s.pop())\n\n\"\"\"Ok!  The definition of a queue is similar. \"\"\"\n\nclass Queue(object):\n\n    def __init__(self):\n        self.queue = []\n\n    def __repr__(self):\n        \"\"\"Defining a __repr__ function will enable us to print the\n        queue contents, and facilitate debugging.\"\"\"\n        return repr(self.queue) # Good enough.\n\n    def add(self, x):\n        self.queue.append(x)\n\n    def get(self):\n        # This is the only difference compared to the stack above.\n        return self.queue.pop(0) if len(self.queue) > 0 else None\n\n    def isempty(self):\n        return len(self.queue) == 0\n    \n    def __len__(self):\n        return len(self.queue)\n    \n    def __iter__(self):\n        for el in self.queue:\n            yield el\n            \n    def __getitem__(self, i):\n        return self.queue[i]\n    \n    def __contains__(self, x):\n        return x in self.queue\n\n\"\"\"Let's see how it works. \"\"\"\n\ns = Queue()\nprint(s.get())\ns.add('a')\ns.add('b')\nprint(s.get())\nprint(s.get())\nprint(s.get())\n\n\"\"\"As you see, in a queue, the elements are retrieved in the same order in which they were added.\n\nPython experts might note that, for a queue, we would do better by using the [`collections.deque` class](https://docs.python.org/3.7/library/collections.html#collections.deque), rather than the list class, to make the `pop(0)` operation more efficient; in lists, it takes time proportional to the length of the list; in deques, it takes constant time.  For small lists, however, the difference is negligible.\n\nWe now consider a use case in which we may need to put in the queue or stack many repeated copies of the same object.  For instance, assume that the queue is used to store events, and assume that some event may end up being repeated many times in a row.  As an example, the events can be \"s\", for the tick of a second, \"m\", when the minute advances, and \"h\", when the hour advances.  There will be 60 consecutive \"s\" events between any two \"m\" events, and it seems a waste to store so many consecutive identical events.  Storing many identical things in a row is akin to counting in unary notation, after all.  We would be better off storing the repeated elements only once, along with a count of the number of times they occur.  Let's develop a queue using this idea (a stack can be done similarly).\n\"\"\"\n\nclass CountingQueue(object):\n\n    def __init__(self):\n        self.queue = []\n\n    def __repr__(self):\n        return repr(self.queue)\n\n    def add(self, x, count=1):\n        # If the element is the same as the last element, we simply\n        # increment the count.  This assumes we can test equality of\n        # elements.\n        if len(self.queue) > 0:\n            xx, cc = self.queue[-1]\n            if xx == x:\n                self.queue[-1] = (xx, cc + count)\n            else:\n                self.queue.append((x, count))\n        else:\n            self.queue = [(x, count)]\n\n    def get(self):\n        if len(self.queue) == 0:\n            return None\n        x, c = self.queue[0]\n        if c == 1:\n            self.queue.pop(0)\n            return x\n        else:\n            self.queue[0] = (x, c - 1)\n            return x\n\n    def isempty(self):\n        # Since the count of an element is never 0, we can just check\n        # whether the queue is empty.\n        return len(self.queue) == 0\n\n\"\"\"Let's put this to the same test as before, printing the queue contents at each step to see what is going on.\"\"\"\n\nq = CountingQueue()\nq.add('a')\nprint(q)\nq.add('b', count=5)\nprint(q)\nq.add('c', count=2)\nprint(q)\nwhile not q.isempty():\n    print(q.get())\n    print(q)\n\n\"\"\"It works!  And notice that it works even if we add elements one by one.\"\"\"\n\nq = CountingQueue()\nfor i in range(10):\n    q.add('a')\nq.add('b')\nfor i in range(3):\n    q.add('c', count=2)\nprint(q)\n\n\"\"\"## The Homework Assignment\n\nFor this homework, you must implement the following methods for `CountingQueue`: \n\n* `__len__`\n* `__iter__`\n* `__in__`\n* `__getitem__`\n\nYour goal is to have `CountingQueue` behave exactly like `Queue` to an outside user: the objects have to be different only due to their internal implementation.  So for instance, `__len__` must return the number of elements, including repetitions; not the number of (element, count) pairs in `self.queue`. \n\nNote that we are adding methods to a class that has already been defined, so our definition have the following somewhat unusual form: \n\"\"\"\n\ndef counting_queue_peek(self):\n    if len(self.queue) == 0:\n        return None\n    el, _ = self.queue[0]\n    return el\n\nCountingQueue.peek = counting_queue_peek\n\n\"\"\"In other words, we first create a function (in this case `counting_queue_peek`) and then we assign it to the method `peek` of `CountingQueue`.  It's a bit unusual, but it works, and it relieves us from the task of redefining the class each time we need a new method. \"\"\"\n\nq = CountingQueue()\nq.add(\"cat\")\nq.add(\"dog\")\nq.peek()\n\n\"\"\"### `__len__`\"\"\"\n\ndef counting_queue_len(self):\n\n    if len(self.queue) == 0:\n        return len(self.queue)\n    else:\n        pass\n    count = 0\n    for i in self.queue:\n        l, r = i\n        count += r\n    return count\n\nCountingQueue.__len__ = counting_queue_len\n\n# 5 points.  Simple tests\n\nq = CountingQueue()\nassert len(q) == 0\nq.add(\"cat\")\nq.add(\"dog\")\nassert len(q) == 2\n\n# 5 points.  More complicated tests. \n\nq = CountingQueue()\nassert len(q) == 0\nq.add(\"cat\")\nq.add(\"cat\")\nassert len(q.queue) == 1\nassert len(q) == 2\nq.add(\"dog\")\nassert len(q) == 3\nassert len(q.queue) == 2\nq.add(\"dog\")\nassert len(q) == 4\nassert len(q) == 4 # Hey, just in case you went for the quantum-mechanical solution ;-) \nassert len(q) == 4\nassert len(q.queue) == 2\n\n# 5 points.  Works same as Queue. \n\nimport random \n\nfor k in range(100):\n    q0 = Queue()\n    q1 = CountingQueue()\n    for _ in range(100):\n        el = random.choice([\"a\", \"b\", \"c\"])\n        q0.add(el)\n        q1.add(el)\n        assert len(q0) == len(q1)\n        assert len(q0.queue) >= len(q1.queue)\n\n\"\"\"### `__iter__`\"\"\"\n\ndef counting_queue_iter(self):\n    for i in self.queue:\n        l, r = i\n        for x in range(r):\n            yield(l)\nCountingQueue.__iter__ = counting_queue_iter\n\n# 5 points.  Simple tests. \n\nq = CountingQueue()\nq.add(\"cat\", count=2)\nq.add(\"dog\", count=3)\nassert [x for x in q] == [\"cat\"] * 2 + [\"dog\"] * 3\n\n# 5 points.  Works the same as queue. \n\nfor k in range(100):\n    q0 = Queue()\n    q1 = CountingQueue()\n    for _ in range(100):\n        el = random.choice([\"a\", \"b\", \"c\"])\n        q0.add(el)\n        q1.add(el)\n        assert [x for x in q0] == [x for x in q1]\n\n\"\"\"### `__in__`\"\"\"\n\ndef counting_queue_in(self, el):\n    ### YOUR CODE HERE\n    pass\nCountingQueue.__in__ = counting_queue_in\n\n# 5 points.  Simple cases. \n\nq = CountingQueue()\nassert \"cat\" not in q\nq.add(\"cat\", count=2)\nassert \"cat\" in q\nassert \"dog\" not in q\nq.add(\"dog\")\nassert \"cat\" in q\nassert \"dog\" in q\nq.get()\nassert \"cat\" in q\nassert \"dog\" in q\nq.get()\nassert \"cat\" not in q\nassert \"dog\" in q\nq.get()\nassert \"cat\" not in q\nassert \"dog\" not in q\n\n# 5 points.  Behaves the same as Queue. \n\nelements = range(5)\nfor k in range(100):\n    q0 = Queue()\n    q1 = CountingQueue()\n    for _ in range(20):\n        el = random.choice(elements)\n        q0.add(el)\n        q1.add(el)\n        for x in elements:\n            assert (x in q0) == (x in q1)\n\n\"\"\"### `__getitem__`\"\"\"\n\ndef counting_queue_getitem(self, n):\n    if n >= len(self) or n < 0:\n        raise IndexError\n    if type(n) != int:\n        raise TypeError\n    ind = 0\n    for i in self.queue:\n        l, r = i\n        for i in range(r):  \n            if n == ind:\n                return l\n            ind += 1\nCountingQueue.__getitem__ = counting_queue_getitem\n\n# 5 points: simple tests. \n\nq = CountingQueue()\nq.add(\"cat\", count=2)\nq.add(\"dog\", count=3)\nq.add(\"bird\", count=4)\nels = [q[i] for i in range(9)]\nassert els == ['cat'] * 2 + ['dog'] * 3 + ['bird'] * 4\n# Let's do it again. \nels = [q[i] for i in range(9)]\nassert els == ['cat'] * 2 + ['dog'] * 3 + ['bird'] * 4\n\n# 5 points: you raise IndexError when accessing elements out of bounds. \n\nq = CountingQueue()\nq.add(\"cat\", count=2)\nq.add(\"dog\", count=3)\n\n# Raise IndexError when it's too high... \ntry:\n    q[5]\n    assert False, \"Failed to raise IndexError\"\nexcept IndexError:\n    pass\nassert q[4] == \"dog\"\ntry:\n    q[5]\n    assert False, \"Failed to raise IndexError\"\nexcept IndexError:\n    pass\n\n# And also when it's too low. \ntry:\n    q[-1]\n    assert False, \"Failed to raise IndexError\"\nexcept IndexError:\n    pass\n\n# And raise TypeError if you try to index with a non-integer. \ntry:\n    q[\"hello\"]\n    assert False, \"Failed to raise TypeError\"\nexcept TypeError:\n    pass\n\n# 5 points.  Behaves the same as Queue. \n\nelements = range(3)\nfor k in range(100):\n    q0 = Queue()\n    q1 = CountingQueue()\n    for m in range(40):\n        el = random.choice(elements)\n        q0.add(el)\n        q1.add(el)\n        for i in range(m):\n            assert q0[i] == q1[i]`\n- المفهوم: `A data structure that internally represents consecutive identical items with a single item and a count, maintaining a standard external interface.`"
        },
        "concurrency": {
            "type": "concurrency",
            "blueprint": "يبدو أن هناك تداخلاً هنا، حيث أن الكود المقدم هو بلغة Go وليس بايثون كما هو مذكور في التعليمات. سأقوم بتحليل كود Go المقدم.\n\n- الكود: (الكود المقدم بلغة Go)\n- المفهوم: `Setting up a basic web server to handle HTTP requests and generate responses.`\n(إعداد خادم ويب أساسي لمعالجة طلبات HTTP وتوليد الاستجابات.)"
        },
        "networking": {
            "type": "networking",
            "blueprint": "- الكود: (النص المقدم)\n- المفهوم: `A structured outline of open-source projects seeking mentored student contributions.`"
        },
        "hash_maps": {
            "type": "hash_maps",
            "blueprint": "**ملاحظة هامة:** الكود المقدم ليس بايثون بل هو **برنامج نصي لـ Bash (Bash script)**. سأقوم بتحليله على هذا الأساس.\n\n-   **الكود:** (تم توفيره أعلاه)\n-   **المفهوم:** `Automating the execution and testing of code examples across multiple programming languages based on their system availability.`"
        },
        "testing": {
            "type": "testing",
            "blueprint": "المفهوم: `The documented evolution of a software project through successive versions.`"
        },
        "version_control": {
            "type": "version_control",
            "blueprint": "المفهوم: `A comprehensive set of guidelines and practices for developing high-quality, maintainable, and readable Python software.`"
        },
        "debugging": {
            "type": "debugging",
            "blueprint": "يبدو أن النص الذي قدمته ليس مقتطف كود بايثون، بل هو سجل تغييرات (Changelog) لمشروع برنامج يدعى `xboxdrv`.\n\nالمفهوم: `A chronological log of changes, fixes, and new features in a software's version history.`"
        },
        "classes": {
            "type": "classes",
            "blueprint": "المقتطف المقدم ليس مقتطف كود بايثون بالمعنى التقليدي (مثل دالة أو كلاس)، بل هو **سجل تغييرات (Changelog)** أو ملاحظات إصدار لمكتبة بايثون تسمى `fido2`.\n\n- المفهوم: `A chronological record of changes, new features, and bug fixes across a software project's versions.`"
        },
        "searching_algorithm": {
            "type": "searching_algorithm",
            "blueprint": "A nested data structure for organizing related information using key-value pairs."
        }
    }
}