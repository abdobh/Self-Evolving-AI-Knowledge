{
    "rules": {
        "string_manipulation_rule_from_search": {
            "type": "string_manipulation",
            "values": [],
            "linked_to": [],
            "source": "external_search",
            "confidence": 70,
            "last_verified": "2025-08-25T00:56:05.295410"
        },
        "semantic_relation_planet": {
            "type": "semantic",
            "values": [
                "planet http://www.wikidata.org/prop/direct/P31 astronomical object type"
            ],
            "linked_to": [],
            "source": "open_source_db_search",
            "confidence": 80,
            "last_verified": "2025-08-25T00:41:15.076175"
        },
        "add_value": {
            "type": "mathematical",
            "values": [
                -46,
                -42,
                -37,
                -24,
                -23,
                -21,
                -16,
                -13,
                -10,
                -4,
                -3,
                1,
                4,
                5,
                12,
                16,
                22,
                27,
                34,
                45,
                48,
                147
            ],
            "linked_to": [],
            "source": "internal_reasoning",
            "confidence": 90,
            "last_verified": "2025-08-25T00:55:20.077386"
        },
        "wikidata_relation_P17": {
            "type": "geographical",
            "values": [
                "Cairo -> http://www.wikidata.org/prop/direct/P17 -> Egypt",
                "London -> http://www.wikidata.org/prop/direct/P17 -> United Kingdom",
                "Paris -> http://www.wikidata.org/prop/direct/P17 -> France",
                "Tokyo -> http://www.wikidata.org/prop/direct/P17 -> Japan"
            ],
            "linked_to": [],
            "source": "open_source_db_search",
            "confidence": 80,
            "last_verified": "2025-08-25T00:55:36.582946"
        },
        "self_built_algorithm_control_flow": {
            "type": "control_flow",
            "value": "\n# خوارزمية تم توليدها ذاتيًا لطباعة الأرقام\ndef print_numbers(start, end):\n    # نستخدم حلقة `for` لتكرار العملية\n    for number in range(start, end + 1):\n        print(number)\n\n# مثال على الاستخدام:\nprint_numbers(1, 5)\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:00:16.576670"
        },
        "self_built_algorithm_function_definition": {
            "type": "function_definition",
            "value": "\n# خوارزمية تم توليدها ذاتيًا لتعريف دالة جمع\ndef add_two_numbers(a, b):\n    # نقوم بعملية الجمع البسيطة\n    return a + b\n\n# مثال على الاستخدام:\nresult = add_two_numbers((2, 5), 7)\nprint(f\"ناتج جمع (2, 5) و 7 هو: {result}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:00:28.910355"
        },
        "self_built_algorithm_data_structures": {
            "type": "data_structures",
            "value": "\n# خوارزمية تم توليدها ذاتيًا لتحويل قائمة إلى قاموس\ndef convert_list_to_dict(input_list):\n    # نستخدم فهم القاموس لتنفيذ العملية\n    output_dict = {item: True for item in input_list}\n    return output_dict\n\n# مثال على الاستخدام:\nmy_list = [5, 20, 25]\nmy_dict = convert_list_to_dict(my_list)\nprint(f\"القائمة الأصلية: {my_list}\")\nprint(f\"القاموس الناتج: {my_dict}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:00:41.089495"
        },
        "self_built_algorithm_simple_arithmetic": {
            "type": "simple_arithmetic",
            "value": "\n# خوارزمية تم توليدها ذاتيًا لعملية حسابية\ndef find_relation(start_val, target_val):\n    # نوجد الفرق بين الرقمين\n    difference = target_val - start_val\n    # يمكننا إضافة Difference لتصل إلى Target\n    return start_val + difference\n\n# مثال على الاستخدام:\nresult = find_relation(38, 111)\nprint(f\"العلاقة بين 38 و 111 هي: {result}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:00:52.956896"
        },
        "self_built_algorithm_sorting_algorithm": {
            "type": "sorting_algorithm",
            "value": "\n# خوارزمية فرز فقاعي تم توليدها ذاتيًا\ndef bubble_sort(unsorted_list):\n    n = len(unsorted_list)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if unsorted_list[j] > unsorted_list[j+1]:\n                unsorted_list[j], unsorted_list[j+1] = unsorted_list[j+1], unsorted_list[j]\n    return unsorted_list\n\n# مثال على الاستخدام:\nmy_list = [3, 50, 35, 38, 16]\nsorted_list = bubble_sort(my_list)\nprint(f\"القائمة غير المرتبة: {my_list}\")\nprint(f\"القائمة المرتبة: {sorted_list}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:09:34.243223"
        },
        "self_built_algorithm_file_handling": {
            "type": "file_handling",
            "value": "\n# خوارزمية تم توليدها ذاتيًا للتعامل مع الملفات\ndef write_to_file(file_name, content):\n    try:\n        with open(file_name, 'w') as f:\n            f.write(content)\n        print(f\"تم كتابة المحتوى بنجاح في الملف: '{file_name}'\")\n    except Exception as e:\n        print(f\"حدث خطأ أثناء الكتابة إلى الملف: {e}\")\n\n# مثال على الاستخدام:\nfile_to_write = \"test_file.txt\"\ncontent_to_write = \"تم توليد هذا المحتوى في 2025-08-25T01:09:45.739265\"\nwrite_to_file(file_to_write, content_to_write)\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:09:45.739615"
        },
        "self_built_algorithm_oop": {
            "type": "oop",
            "value": "\n# خوارزمية تم توليدها ذاتيًا للبرمجة كائنية التوجه (OOP)\nclass Car:\n    def __init__(self, color=\"red\"):\n        self.color = color\n        print(f\"تم إنشاء كائن جديد من فئة {self.__class__.__name__} بلون {self.color}.\")\n\n    def get_color(self):\n        return self.color\n\n# مثال على الاستخدام:\nmy_car = Car(color=\"blue\")\nprint(f\"لون {instance_name} هو: {my_car.get_color()}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:09:57.616537"
        },
        "self_built_algorithm_recursion": {
            "type": "recursion",
            "value": "\n# دالة مضروب (factorial) تم توليدها ذاتيًا باستخدام العودية (recursion)\ndef factorial(n):\n    # حالة الأساس (Base Case)\n    if n == 0:\n        return 1\n    # الحالة العودية (Recursive Case)\n    else:\n        return n * factorial(n-1)\n\n# مثال على الاستخدام:\nnumber = 7\nresult = factorial(number)\nprint(f\"مضروب الرقم {number} هو: {result}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:10:09.496071"
        },
        "self_built_algorithm_graph_theory": {
            "type": "graph_theory",
            "value": "\nimport collections\n\n# خوارزمية تم توليدها ذاتيًا لإيجاد أقصر مسار (BFS)\ndef find_shortest_path(graph, start, end):\n    # نستخدم قائمة انتظار (queue) لاستكشاف الرسم البياني\n    queue = collections.deque([[start]])\n    visited = {start}\n\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n\n        if node == end:\n            return path\n        \n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append(new_path)\n    \n    return None\n\n# مثال على الاستخدام:\nmy_graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E'], 'D': ['E'], 'E': []}\nstart_node = 'A'\nend_node = 'E'\nshortest_path = find_shortest_path(my_graph, start_node, end_node)\nprint(f\"أقصر مسار من {start_node} إلى {end_node} هو: {shortest_path}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:18:17.161250"
        }
    },
    "meta_rules": {
        "data_structures": {
            "type": "data_structures",
            "blueprint": "Use dictionary comprehension to create dictionaries from iterables."
        },
        "control_flow": {
            "type": "control_flow",
            "blueprint": "Use a `for` loop with `range` to iterate a specific number of times."
        },
        "function_definition": {
            "type": "function_definition",
            "blueprint": "Define a function with a `def` keyword, parameters, and a `return` statement."
        },
        "simple_arithmetic": {
            "type": "simple_arithmetic",
            "blueprint": "Perform simple mathematical operations (+, -, *, /) to find relationships between numbers."
        },
        "sorting_algorithm": {
            "type": "sorting_algorithm",
            "blueprint": "Implement sorting by iterating and swapping adjacent elements in a list."
        },
        "recursion": {
            "type": "recursion",
            "blueprint": "A function calls itself to solve a problem, with a clear base case to stop."
        },
        "file_handling": {
            "type": "file_handling",
            "blueprint": "Use `with open(...) as f:` to safely read from or write to a file."
        },
        "oop": {
            "type": "oop",
            "blueprint": "Define a `class` with an `__init__` method and attributes to create reusable objects."
        },
        "graph_theory": {
            "type": "graph_theory",
            "blueprint": "Use Breadth-First Search (BFS) to find the shortest path in an unweighted graph."
        }
    }
}