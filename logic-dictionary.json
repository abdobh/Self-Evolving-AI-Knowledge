{
    "rules": {
        "string_manipulation_rule_from_search": {
            "type": "string_manipulation",
            "values": [],
            "linked_to": [],
            "source": "external_search",
            "confidence": 70,
            "last_verified": "2025-08-25T00:56:05.295410"
        },
        "semantic_relation_planet": {
            "type": "semantic",
            "values": [
                "planet http://www.wikidata.org/prop/direct/P31 astronomical object type"
            ],
            "linked_to": [],
            "source": "open_source_db_search",
            "confidence": 80,
            "last_verified": "2025-08-25T00:41:15.076175"
        },
        "add_value": {
            "type": "mathematical",
            "values": [
                -46,
                -42,
                -37,
                -24,
                -23,
                -21,
                -16,
                -13,
                -10,
                -4,
                -3,
                1,
                4,
                5,
                12,
                16,
                22,
                27,
                34,
                45,
                48,
                147
            ],
            "linked_to": [],
            "source": "internal_reasoning",
            "confidence": 90,
            "last_verified": "2025-08-25T00:55:20.077386"
        },
        "wikidata_relation_P17": {
            "type": "geographical",
            "values": [
                "Cairo -> http://www.wikidata.org/prop/direct/P17 -> Egypt",
                "London -> http://www.wikidata.org/prop/direct/P17 -> United Kingdom",
                "Paris -> http://www.wikidata.org/prop/direct/P17 -> France",
                "Tokyo -> http://www.wikidata.org/prop/direct/P17 -> Japan"
            ],
            "linked_to": [],
            "source": "open_source_db_search",
            "confidence": 80,
            "last_verified": "2025-08-25T00:55:36.582946"
        },
        "self_built_algorithm_control_flow": {
            "type": "control_flow",
            "value": "\n# خوارزمية تم توليدها ذاتيًا لطباعة الأرقام\ndef print_numbers(start, end):\n    # نستخدم حلقة `for` لتكرار العملية\n    for number in range(start, end + 1):\n        print(number)\n\n# مثال على الاستخدام:\nprint_numbers(1, 5)\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:00:16.576670"
        },
        "self_built_algorithm_function_definition": {
            "type": "function_definition",
            "value": "\n# خوارزمية تم توليدها ذاتيًا لتعريف دالة جمع\ndef add_two_numbers(a, b):\n    # نقوم بعملية الجمع البسيطة\n    return a + b\n\n# مثال على الاستخدام:\nresult = add_two_numbers((2, 5), 7)\nprint(f\"ناتج جمع (2, 5) و 7 هو: {result}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:00:28.910355"
        },
        "self_built_algorithm_data_structures": {
            "type": "data_structures",
            "value": "\n# خوارزمية تم توليدها ذاتيًا لتحويل قائمة إلى قاموس\ndef convert_list_to_dict(input_list):\n    # نستخدم فهم القاموس لتنفيذ العملية\n    output_dict = {item: True for item in input_list}\n    return output_dict\n\n# مثال على الاستخدام:\nmy_list = [5, 20, 25]\nmy_dict = convert_list_to_dict(my_list)\nprint(f\"القائمة الأصلية: {my_list}\")\nprint(f\"القاموس الناتج: {my_dict}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:00:41.089495"
        },
        "self_built_algorithm_simple_arithmetic": {
            "type": "simple_arithmetic",
            "value": "\n# خوارزمية تم توليدها ذاتيًا لعملية حسابية\ndef find_relation(start_val, target_val):\n    # نوجد الفرق بين الرقمين\n    difference = target_val - start_val\n    # يمكننا إضافة Difference لتصل إلى Target\n    return start_val + difference\n\n# مثال على الاستخدام:\nresult = find_relation(38, 111)\nprint(f\"العلاقة بين 38 و 111 هي: {result}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:00:52.956896"
        },
        "self_built_algorithm_sorting_algorithm": {
            "type": "sorting_algorithm",
            "value": "\n# خوارزمية فرز فقاعي تم توليدها ذاتيًا\ndef bubble_sort(unsorted_list):\n    n = len(unsorted_list)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if unsorted_list[j] > unsorted_list[j+1]:\n                unsorted_list[j], unsorted_list[j+1] = unsorted_list[j+1], unsorted_list[j]\n    return unsorted_list\n\n# مثال على الاستخدام:\nmy_list = [3, 50, 35, 38, 16]\nsorted_list = bubble_sort(my_list)\nprint(f\"القائمة غير المرتبة: {my_list}\")\nprint(f\"القائمة المرتبة: {sorted_list}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:09:34.243223"
        },
        "self_built_algorithm_file_handling": {
            "type": "file_handling",
            "value": "\n# خوارزمية تم توليدها ذاتيًا للتعامل مع الملفات\ndef write_to_file(file_name, content):\n    try:\n        with open(file_name, 'w') as f:\n            f.write(content)\n        print(f\"تم كتابة المحتوى بنجاح في الملف: '{file_name}'\")\n    except Exception as e:\n        print(f\"حدث خطأ أثناء الكتابة إلى الملف: {e}\")\n\n# مثال على الاستخدام:\nfile_to_write = \"test_file.txt\"\ncontent_to_write = \"تم توليد هذا المحتوى في 2025-08-25T01:09:45.739265\"\nwrite_to_file(file_to_write, content_to_write)\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:09:45.739615"
        },
        "self_built_algorithm_oop": {
            "type": "oop",
            "value": "\n# خوارزمية تم توليدها ذاتيًا للبرمجة كائنية التوجه (OOP)\nclass Car:\n    def __init__(self, color=\"red\"):\n        self.color = color\n        print(f\"تم إنشاء كائن جديد من فئة {self.__class__.__name__} بلون {self.color}.\")\n\n    def get_color(self):\n        return self.color\n\n# مثال على الاستخدام:\nmy_car = Car(color=\"blue\")\nprint(f\"لون {instance_name} هو: {my_car.get_color()}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:09:57.616537"
        },
        "self_built_algorithm_recursion": {
            "type": "recursion",
            "value": "\n# دالة مضروب (factorial) تم توليدها ذاتيًا باستخدام العودية (recursion)\ndef factorial(n):\n    # حالة الأساس (Base Case)\n    if n == 0:\n        return 1\n    # الحالة العودية (Recursive Case)\n    else:\n        return n * factorial(n-1)\n\n# مثال على الاستخدام:\nnumber = 7\nresult = factorial(number)\nprint(f\"مضروب الرقم {number} هو: {result}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:10:09.496071"
        },
        "self_built_algorithm_graph_theory": {
            "type": "graph_theory",
            "value": "\nimport collections\n\n# خوارزمية تم توليدها ذاتيًا لإيجاد أقصر مسار (BFS)\ndef find_shortest_path(graph, start, end):\n    # نستخدم قائمة انتظار (queue) لاستكشاف الرسم البياني\n    queue = collections.deque([[start]])\n    visited = {start}\n\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n\n        if node == end:\n            return path\n        \n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append(new_path)\n    \n    return None\n\n# مثال على الاستخدام:\nmy_graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E'], 'D': ['E'], 'E': []}\nstart_node = 'A'\nend_node = 'E'\nshortest_path = find_shortest_path(my_graph, start_node, end_node)\nprint(f\"أقصر مسار من {start_node} إلى {end_node} هو: {shortest_path}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:18:17.161250"
        },
        "self_built_algorithm_string_processing": {
            "type": "string_processing",
            "value": "\nimport collections\nimport re\n\n# خوارزمية تم توليدها ذاتيًا لتحليل النصوص (String Processing)\ndef analyze_text_string(text):\n    # نقوم بتحويل النص إلى أحرف صغيرة وتقسيمه إلى كلمات\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n\n    # نستخدم collections.Counter لعد تكرار كل كلمة\n    word_counts = collections.Counter(words)\n\n    # نطبع النتائج\n    print(f\"النص الأصلي: '{text}'\")\n    print(f\"عدد الكلمات الإجمالي: {len(words)}\")\n    print(f\"عدد تكرار كل كلمة: {dict(word_counts)}\")\n    return dict(word_counts)\n\n# مثال على الاستخدام:\nmy_string = \"Hello world hello world this is a test\"\nanalyze_text_string(my_string)\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:24:17.362088"
        },
        "self_built_algorithm_dynamic_programming": {
            "type": "dynamic_programming",
            "value": "\n# خوارزمية تم توليدها ذاتيًا باستخدام البرمجة الديناميكية (Dynamic Programming)\n# لحساب أرقام فيبوناتشي باستخدام التخزين المؤقت (Memoization)\ndef fibonacci(n, memo={}):\n    # إذا كانت القيمة موجودة بالفعل في الذاكرة المؤقتة، نعيدها مباشرة\n    if n in memo:\n        return memo[n]\n\n    # الحالات الأساسية (Base Cases)\n    if n <= 1:\n        return n\n\n    # حساب القيمة وتخزينها في الذاكرة المؤقتة قبل الإرجاع\n    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n    return memo[n]\n\n# مثال على الاستخدام:\nnumber_to_calculate = 8\nresult = fibonacci(number_to_calculate)\nprint(f\"قيمة فيبوناتشي للعدد {number_to_calculate} هي: {result}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:28:20.053795"
        },
        "self_built_algorithm_search_and_optimization": {
            "type": "search_and_optimization",
            "value": "\nimport heapq\nimport math\n\n# خوارزمية A* تم توليدها ذاتيًا لإيجاد أقصر مسار على شبكة\ndef a_star_pathfinding(grid, start, end):\n    # دالة التقدير (Heuristic) - مسافة مانهاتن\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    rows, cols = len(grid), len(grid[0])\n    # F-score (g-score + heuristic)\n    f_score = {node: float('inf') for row in range(rows) for node in range(cols)}\n    f_score[start] = heuristic(start, end)\n    \n    # G-score (التكلفة من البداية)\n    g_score = {node: float('inf') for row in range(rows) for node in range(cols)}\n    g_score[start] = 0\n\n    # قائمة الأولوية للعقد المراد استكشافها\n    open_list = [(f_score[start], start)]\n    came_from = {}\n\n    while open_list:\n        current_f, current_node = heapq.heappop(open_list)\n        \n        if current_node == end:\n            # إعادة بناء المسار\n            path = []\n            while current_node in came_from:\n                path.append(current_node)\n                current_node = came_from[current_node]\n            path.append(start)\n            path.reverse()\n            return path\n        \n        # استكشاف الجيران\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current_node[0] + dr, current_node[1] + dc)\n            \n            # التحقق من صلاحية الجار\n            if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0:\n                tentative_g_score = g_score[current_node] + 1 # تكلفة الخطوة\n                \n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current_node\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                    heapq.heappush(open_list, (f_score[neighbor], neighbor))\n                    \n    return None\n\n# مثال على الاستخدام:\nmy_grid = [[0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nstart_pos = (0, 0)\nend_pos = (2, 3)\n\npath = a_star_pathfinding(my_grid, start_pos, end_pos)\nprint(f\"الشبكة: {my_grid}\")\nprint(f\"أقصر مسار من {start_pos} إلى {end_pos} هو: {path}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:36:29.594914"
        },
        "self_built_algorithm_kruskal_mst": {
            "type": "kruskal_mst",
            "value": "\n# خوارزمية كروسكال (Kruskal's Algorithm) تم توليدها ذاتيًا لإيجاد شجرة الامتداد الدنيا (MST)\n\n# دالة مساعدة لإيجاد الجذر (find set)\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\n# دالة مساعدة لتوحيد المجموعات (union set)\ndef union(parent, rank, x, y):\n    root_x = find(parent, x)\n    root_y = find(parent, y)\n    if root_x != root_y:\n        if rank[root_x] > rank[root_y]:\n            parent[root_y] = root_x\n        elif rank[root_x] < rank[root_y]:\n            parent[root_x] = root_y\n        else:\n            parent[root_y] = root_x\n            rank[root_x] += 1\n        return True\n    return False\n\ndef kruskal_mst(edges):\n    mst = []\n    edges.sort(key=lambda item: item[2]) # فرز الحواف حسب الوزن\n\n    parent = {}\n    rank = {}\n    for u, v, w in edges:\n        parent[u] = u\n        parent[v] = v\n        rank[u] = 0\n        rank[v] = 0\n\n    num_edges = 0\n    i = 0\n    while num_edges < len(parent) - 1:\n        u, v, w = edges[i]\n        i += 1\n\n        root_u = find(parent, u)\n        root_v = find(parent, v)\n\n        if root_u != root_v:\n            mst.append((u, v))\n            union(parent, rank, root_u, root_v)\n            num_edges += 1\n\n    return mst\n\n# مثال على الاستخدام:\nmy_edges = [('A', 'B', 2), ('A', 'C', 3), ('B', 'C', 4), ('B', 'D', 5), ('C', 'D', 1)]\nmst_edges = kruskal_mst(my_edges)\nprint(f\"قائمة الحواف: {my_edges}\")\nprint(f\"شجرة الامتداد الدنيا (باستخدام كروسكال) هي: {mst_edges}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 75,
            "last_verified": "2025-08-25T01:47:43.984034"
        },
        "self_built_algorithm_prim_mst": {
            "type": "prim_mst",
            "value": "\nimport heapq\n\n# خوارزمية بريم (Prim's Algorithm) تم توليدها ذاتيًا لإيجاد شجرة الامتداد الدنيا (MST)\ndef prim_mst(graph, start_node):\n    mst = []\n    visited = {}\n    min_heap = [(0, start_node, None)] # (weight, node, parent)\n\n    while min_heap:\n        weight, current_node, parent = heapq.heappop(min_heap)\n\n        if current_node in visited:\n            continue\n\n        visited[current_node] = True\n        \n        if parent is not None:\n            mst.append((parent, current_node, weight))\n\n        for neighbor, edge_weight in graph.get(current_node, []):\n            if neighbor not in visited:\n                heapq.heappush(min_heap, (edge_weight, neighbor, current_node))\n    \n    # تحويل قائمة المسارات إلى تنسيق أبسط (node1, node2)\n    simple_mst = [(edge[0], edge[1]) for edge in mst]\n    return simple_mst\n\n# مثال على الاستخدام:\nmy_graph = {'A': [('B', 2), ('C', 3)], 'B': [('A', 2), ('C', 4), ('D', 5)], 'C': [('A', 3), ('B', 4), ('D', 1)], 'D': [('B', 5), ('C', 1)]}\nstart = 'A'\nmst_edges = prim_mst(my_graph, start)\nprint(f\"الرسم البياني: {my_graph}\")\nprint(f\"شجرة الامتداد الدنيا (باستخدام بريم) هي: {mst_edges}\")\n",
            "linked_to": [],
            "source": "self_algorithm_generation",
            "confidence": 95,
            "last_verified": "2025-08-25T01:47:55.711645"
        }
    },
    "meta_rules": {
        "data_structures": {
            "type": "data_structures",
            "blueprint": "Use dictionary comprehension to create dictionaries from iterables."
        },
        "control_flow": {
            "type": "control_flow",
            "blueprint": "Use a `for` loop with `range` to iterate a specific number of times."
        },
        "function_definition": {
            "type": "function_definition",
            "blueprint": "Define a function with a `def` keyword, parameters, and a `return` statement."
        },
        "simple_arithmetic": {
            "type": "simple_arithmetic",
            "blueprint": "Perform simple mathematical operations (+, -, *, /) to find relationships between numbers."
        },
        "sorting_algorithm": {
            "type": "sorting_algorithm",
            "blueprint": "Implement sorting by iterating and swapping adjacent elements in a list."
        },
        "recursion": {
            "type": "recursion",
            "blueprint": "A function calls itself to solve a problem, with a clear base case to stop."
        },
        "file_handling": {
            "type": "file_handling",
            "blueprint": "Use `with open(...) as f:` to safely read from or write to a file."
        },
        "oop": {
            "type": "oop",
            "blueprint": "Define a `class` with an `__init__` method and attributes to create reusable objects."
        },
        "graph_theory": {
            "type": "graph_theory",
            "blueprint": "Use Breadth-First Search (BFS) to find the shortest path in an unweighted graph."
        },
        "string_processing": {
            "type": "string_processing",
            "blueprint": "Use built-in string methods like `.lower()`, `.split()` or regular expressions to analyze text."
        },
        "dynamic_programming": {
            "type": "dynamic_programming",
            "blueprint": "Break a problem into overlapping subproblems, solve each once, and store the result to avoid re-computation (memoization)."
        },
        "search_and_optimization": {
            "type": "search_and_optimization",
            "blueprint": "Use a priority queue and a heuristic function to find the optimal path in a weighted graph."
        },
        "dijkstra_pathfinding": {
            "type": "dijkstra_pathfinding",
            "blueprint": "Use a priority queue to find the shortest path in a weighted graph, prioritizing the lowest cost."
        },
        "prim_mst": {
            "type": "prim_mst",
            "blueprint": "Use a priority queue to build a Minimum Spanning Tree by greedily adding the smallest weight edge to a growing tree."
        },
        "kruskal_mst": {
            "type": "kruskal_mst",
            "blueprint": "Use a Disjoint Set Union (DSU) data structure to build a Minimum Spanning Tree by iterating through sorted edges."
        }
    }
}